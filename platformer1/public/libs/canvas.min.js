let particles = [], snows = [], rains = [], camera, pathIndex = 0; function get(e) { return document.querySelector(e) } function getAll(e) { return document.querySelectorAll(e) } let reqA, imSet = !1, friction = .5, isCamera = !1, tileAnimation, objframe = 0, layerframe = 0, saveBg, frame = 0, delta = 0; const dpr = Math.round(window.devicePixelRatio) || 1, MapScaleX = dpr + 2.362, MapScaleY = dpr + 1.825; let isFake = !1, isDrawable = !1; const log = console.log; let self, rotImage = !1, toJson = JSON.stringify, ctx, buffer, buffer2, scaleX = 1, scaleY = 1, stage, stage2, stage3, stage4; function Stage() { (self = { stage: document.createElement("canvas"), stage2: document.createElement("canvas"), stage3: document.createElement("canvas"), stage4: document.createElement("canvas") }).assetLoader = !1, this.images = {}, this.audios = {}, self.preload = (e, t) => t.endsWith(".png") || t.endsWith(".jpg") || t.endsWith(".jpeg") ? (this.img = new Image, this.img.onload = () => { this.images[e] = this.img, self.assetLoader = !0 }, this.img.onerror = t => { console.error(`Error loading ${e}: ${t.message}`) }, this.img.src = t) : t.endsWith(".mp3") || t.endsWith(".m4a") || t.endsWith(".ogg") || t.endsWith(".wav") ? (this.audio = new Audio, this.audio.onload = () => { this.audios[e] = this.audio, self.assetLoader = !0 }, this.audio.onerror = t => { console.error(`Error loading ${e}: ${t.message}`) }, this.audio.src = t) : void log("Bad file extension for : " + e), Sprite.prototype.useImage = function (e) { let t = this, s = setInterval(() => { if (self.assetLoader) { if (Array.isArray(t)) for (let i of t) i.image.src = e; else t.image.src = e; clearInterval(s) } }, 100); return t }, SpriteSheet.prototype.useImage = function (e) { let t = this, s = setInterval(() => { if (self.assetLoader) { if (Array.isArray(t)) for (let i of t) i.image.src = e; else t.image.src = e; clearInterval(s) } }, 100); return t }, self.use = (e, t, s, i, l) => { if (self.imageLoader) return void 0 != this.images ? this.img = this.images[e] : console.error(`${e} is not loaded.`), this.image }, self.knockBack = function (e, t, s) { e.left ? t.vx = -s : t.vx = s, t.x += t.vx, t.vx *= .6, .1 > Math.abs(t.vx) && (t.vx = 0) }; let e = new AudioContext; self.beep = function (t, s) { try { void 0 == e && (e = new AudioContext); let i = e.createOscillator(); i.type = t; var l = e.createGain(); i.frequency.setValueAtTime(s, e.currentTime), i.connect(l).connect(e.destination), i.start(), i.stop(e.currentTime + .09) } catch (r) { } this.setVolume = e => { l.gain.value = e } }, stage = self.stage, stage2 = self.stage2, stage3 = self.stage3, stage4 = self.stage4, void 0 == self.scale && (self.scale = 1), self.stage.style.position = "fixed", self.stage.style.zIndex = 1, self.stage2.style.zIndex = 2, self.stage3.style.zIndex = 3, self.stage3.style.zIndex = 9999, self.stage.style.imageRendering = "pixelated", self.stage.style.background = "white"; let t = get("body"); function s() { stage.style.objectFit = "contain", t.style.objectFit = "contain", stage.width = gW * dpr, stage.height = gH * dpr; let e = gW / gH, s = window.innerWidth * dpr, i = window.innerHeight * dpr, l, r; self.fullScreen ? s / i >= e ? (l = (r = i) * e, stage.style.width = (l + dpr) * e + "px", stage.style.height = (r + dpr) * e + "px", self.zoom(.2), stage.style.transform = `scale(${MapScaleX},${MapScaleY})`, stage.style.top = "32%") : r = (l = s) / e : (stage.style.top = "35%", screen.availWidth >= 1e3 ? (self.zoom(.8), stage.style.transform = `scale(${MapScaleX},${MapScaleY})`) : screen.availWidth < 1e3 && (stage.style.top = "48%", self.zoom(.42), stage.style.transform = `scale(${MapScaleX},${MapScaleY})`), get("body").className.includes("rotate-90") && (stage.style.top = "40%", self.zoom(.45), stage.style.transform = `scale(${MapScaleX},${MapScaleY})`)) } function i(e, t, s) { return e + (t - e) * s } t.style.margin = 0, t.style.display = "flex", t.style.justifyContent = "center", t.style.alignItems = "center", t.style.overflow = "hidden", t.style.background = "black", t.style.userSelect = "none", self.zoom = function (e) { stage.style.zoom = e }, self.aim = (e, t, s) => { let i = null, l = 1 / 0; t.forEach(t => { let s = self.getDistance(t, e); t.radius = t.radius || t.r || t.w, s < l && (l = s, i = t), t.w ? i.radius = Math.sqrt((t.w / 2) ** 2 + (t.h / 2) ** 2) : i.radius = t.radius }), i && l - i.radius <= s ? "polygon" == e.type ? e.angle = self.getAngle(i, e) : e.angle = self.getAngle(e, i) : e.angle = 0 }, self.flash = function (e) { e.alpha = .3, e.hasShadow = !1, e.flashId = setTimeout(() => { e.alpha = 1, clearTimeout(e.flashId) }, 70) }, self.squash = function (e, t) { e.w = t - 3, e.squashId = setTimeout(() => { e.w = t, clearTimeout(e.squashId) }, 270) }, self.add = function (e, t) { this.b = t, void 0 == t && document.body.appendChild(e), void 0 !== t && "before" == t && document.body.before(e) }, self.delete = function (e) { document.body.removeChild(e) }, self.loadImage = function (e, t) { return this.src = t, this.id = e, this }, self.setSpriteImage = function (e) { try { if (!Array.isArray(sprite) && sprite.id == e.id) return sprite.image.src = e.src; for (let t of sprite) t.id == e.id && (t.image.src = e.src) } catch (s) { } }, self.stage.setBg = function (e, t) { self.stage.style.backgroundRepeat = t, self.stage.style.objectFit = "contain", this.c = e, isFake && (l = this.c || "transparent"), void 0 == this.c || void 0 == e || "" == this.c ? (self.stage.style.background = l, self.stage2.style.background = "transparent", self.stage3.style.background = "transparent", self.stage4.style.background = "transparent") : isFake && void 0 == this.c || void 0 == e || "" == this.c ? (self.stage.style.background = "transparent", self.stage2.style.background = "transparent", self.stage3.style.background = "transparent", self.stage4.style.background = "transparent") : this.c && !isFake && (l = this.c, self.stage.style.background = l, self.stage2.style.background = "transparent", self.stage3.style.background = "transparent", self.stage4.style.background = "transparent"), void 0 != this.c || isFake || (l = "rgba(17,34,51,0.8)", self.stage.style.background = l, self.stage2.style.background = "transparent", self.stage3.style.background = "transparent", self.stage4.style.background = "transparent") }, self.getGridPosition = function (e, t, s, i) { return { x: Math.floor(e / s), y: Math.floor(t / i) } }, self.parse2D = function (e) { if (loader) { let t = []; for (let s = 0; s < e.height; s++) { t[s] = []; for (let i = 0; i < e.width; i++) { let l = s * e.width + i; t[s][i] = e.data[l] } } return t } }, self.pageLoad = !1, document.addEventListener("DOMContentLoaded", function () { try { self.create(), self.pageLoad = !0 } catch (e) { log() } }), self.setSize = function (e, t) { this.a = e * self.scale, this.b = t * self.scale, this.a && this.b && (gW = self.stage.width = self.stage2.width = self.stage3.width = self.stage4.width = this.a, gH = self.stage.height = self.stage2.height = self.stage3.height = self.stage4.height = this.b) }, void 0 == this.a && void 0 == this.b && (gW = self.stage.width = self.stage2.width = self.stage3.width = 320, gH = self.stage.height = self.stage2.height = self.stage3.height = 180), self.fullScreen = !1, window.addEventListener("DOMContentLoaded", s), window.addEventListener("resize", function () { s() }), camera = { x: 0, y: 0, width: gW, height: gH }, self.stage.style.imageRendering = "pixelated", self.stage2.style.imageRendering = "pixelated", self.stage3.style.imageRendering = "pixelated", ctx = self.stage.getContext("2d"), buffer = self.stage2.getContext("2d"), buffer2 = self.stage3.getContext("2d"), buffer3 = self.stage4.getContext("2d"), rectColor = function (e) { buffer.fillStyle = e }, strokeColor = function (e) { buffer.strokeStyle = e }, Rect = function (e, t = e.color) { buffer.fillStyle = t, buffer.fillRect(e.x, e.y, e.w, e.h) }, Stroke = function (e, t = e.color) { buffer.strokeStyle = t, buffer.strokeRect(e.x, e.y, e.w, e.h) }, self.spriteAnimator = function (e, t, s, i, l, r = !1) { return this.speed = l, this.src = t, this.startIndex = i, this.nbFrame = s, this.obj = e, this.startIndex > 0 ? this.index = frame % this.nbFrame + 1 : this.index = frame % this.nbFrame, this.parenth = r, this.parenth ? this.anim = ` ${this.src}(${this.index}).png` : this.anim = ` ${this.src}${this.index}.png`, frame % this.speed == 0 && (this.obj.image.src = this.anim), this.index }, self.getObjectLayer = e => { let t = data.layers.find(t => t.name == e && "objectgroup" == t.type); return t ? t.objects : null }, self.normalized = function (e) { let t = Math.sqrt(e.vx * e.vx + e.vy * e.vy); t > 0 && (e.vx = e.vx / t, e.vy = e.vy / t) }, window.onload = function () { self.start ? self.start() : self.start = function () { } }, self.setDetector = function (e, t = !1) { e.show = t, (e.collider || "boolean" == typeof t) && (e.detector = { x: e.collider.x, y: e.collider.y + e.collider.h + 2, w: 15, h: 4, color: "rgba(25,250,255,0.5)" }, e.left ? e.detector.x = e.x - 2 : e.detector.x = e.detector.x + 4) }, self.isLimitReach = (e, t) => { let s = Math.abs(e.y + e.h - (t.y + t.height)); return !(e.x < t.x + t.width) || !(e.x + e.w > t.x) || !(e.y + e.h > s) }, self.patrolLimit = function (e, t) { if (isCollide(e, t)) return e.y, t.y, e.x + e.w / 2 <= t.x || e.x + e.w >= t.x + t.width || !!isCollide(e, t) && !!(e.x + e.w / 2 <= t.x) || !!(e.x + e.w >= t.x + t.width) }, self.useDarkness = function (e) { buffer.save(), buffer3.clearRect(0, 0, gW, gH), buffer3.fillStyle = `rgba(0,0,0,${e})`, buffer3.fillRect(0, 0, gW, gH), buffer.restore() }, self.overLay = function () { opacity = 1, self.stage.style.zIndex = -999, self.stage2.style.zIndex = -999; var e = document.createElement("div"); t.appendChild(e), e.style.width = "2500px", e.style.height = "2500px", e.style.position = "fixed", e.style.zIndex = 99999, e.style.background = `rgba(0, 0, 0, ${opacity})`, e.style.left = "0%", e.style.top = "0%", setTimeout(function () { opacity -= .02, e.style.background = `rgba(0, 0, 0, ${opacity})` }, 300), setTimeout(function () { opacity -= .04, e.style.background = `rgba(0, 0, 0, ${opacity})` }, 600), setTimeout(function () { opacity -= .06, e.style.background = `rgba(0, 0, 0, ${opacity})` }, 900), setTimeout(function () { opacity -= .08, e.style.background = `rgba(0, 0, 0, ${opacity})` }, 1e3), setTimeout(function () { opacity -= .2, e.style.background = `rgba(0, 0, 0, ${opacity})` }, 1200), setTimeout(function () { opacity -= .4, e.style.background = `rgba(0, 0, 0, ${opacity})` }, 1400), setTimeout(function () { opacity = 0, e.style.background = `rgba(0, 0, 0, ${opacity})`, document.body.removeChild(e) }, 1500) }, Text = function (e, t, s, i, l, r, a) { this.x = r, this.y = a, this.color = e || "gold", this.fontsize = s, this.fontstyle = t, this.fontfamily = i, this.t = l, void 0 == this.fontweight && (this.fontweight = "bold"), void 0 == this.fontstyle && (this.fontstyle = "italic"), (void 0 == this.fontfamily || null == this.fontfamily) && (this.fontfamily = "monospace"), buffer.fillStyle = this.color, buffer.font = this.fontstyle + " " + this.fontsize + " " + this.fontfamily, buffer.fillText(this.t, this.x, this.y) }, clear = function () { buffer.clearRect(camera.x, camera.y, camera.width, camera.health) }, self.getDistance = function (e, t) { if (this.a = e, this.b = t, this.a.startX && "polygon" == this.a.type) { var s = Math.abs(this.a.startX - this.b.startX), i = Math.abs(this.a.startY - this.b.startY), l = Math.hypot(s, i); return l } if ("line" == t.type || t.x1) { var s = this.a.x - this.b.x1, i = this.a.y - this.b.y1, l = Math.hypot(s, i); return l } if (void 0 != this.a.collider && void 0 != this.b.collider) { var s = this.a.collider.x - this.b.collider.x, i = this.a.collider.y - this.b.collider.y, l = Math.hypot(s, i); return l } if (this.a.collider || this.b.collider) { if (this.a.collider && !this.b.collider) { var s = this.a.collider.x - this.b.x, i = this.a.collider.y - this.b.y, l = Math.hypot(s, i); return l } if (!this.a.collider && this.b.collider) { var s = Math.abs(this.a.x - this.b.collider.x), i = Math.abs(this.a.y - this.b.collider.y), l = Math.hypot(s, i); return l } } else { var s = this.a.x - this.b.x, i = this.a.y - this.b.y, l = Math.hypot(s, i); return l } }, self.getAngle = function (e, t) { try { if (this.a = e, this.b = t, !this.a.startX && !this.b.startX) { var s = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x); return s + 90 * Deg2Rad } if (this.a.startX && this.b.startX) { var s = Math.atan2(this.a.startY - this.b.startY, this.a.startX - this.b.startX); return s } if (!this.a.startX && this.b.startX) var s = Math.atan2(Math.abs(this.a.y - this.b.startY), Math.abs(this.a.x - this.b.startX)); return s + 90 * Deg2Rad } catch (i) { log(i) } return s }, self.isClosest = function (e, t) { return distance = self.getDistance(e, t) }, self.hasLineOfSight = function (e, t, s) { t.x, e.x, t.y, e.y, e.x, s.x, e.y, s.y; let i = { x: t.x + t.w / 2, y: t.y + t.h / 2, w: e.x + e.w / 2, h: e.y + e.h / 2, color: "green" }; return (buffer.strokeStyle = i.color, isCollide(i, s) || (buffer.moveTo(i.x, i.y), buffer.lineTo(i.w, i.h)), buffer.stroke(), isCollide(i, s)) ? (i.color = "red", !1) : (i.color = "green", !0) }, self.avoidSameOverlapping = function (e) { for (let t = 0; t < e.length; t++)for (let s = t + 1; s < e.length; s++) { let i = 16 * delta, l = 16 * delta; isCollide(e[t], e[s]) && (e[t].x = e[t].x + i, e[t].y = e[t].y + l), "polygon" == e[t].type && "polygon" == e[s].type && e[t].checkCollision(e[s]) && (e[t].startX = e[t].startX + i + 6 * e[t].radius, e[t].startY = e[t].startY + l + 6 * e[t].radius) } }, self.onElevator = function (e, t) { return !!(e.collider.x + e.collider.w >= t.x) && !!(e.collider.x <= t.x + t.width) && !!(e.collider.y + e.collider.h > t.y - t.height) && !!(e.collider.y < t.y + t.height) }, self.setCollider = (e, t) => { t || (t = !1), e.isVisible = t, "boolean" != typeof t && (e.isVisible = !1, console.warn("Only a boolean is required in collider method !")), e.sw > 100 || e.sh > 100 ? e.collider = { x: e.x + e.w / 2.14, y: e.y + e.h / 3, w: e.w / 8, h: e.h / 3, vx: e.vx, vy: e.vy, color: "rgba(255,0,0,0.5)" } : (e.collider = { x: e.x + e.w / 1.7, y: e.y + e.h / 4.5, w: e.w / 4, h: e.h - 7, color: "rgba(255,0,0,0.5)" }, e.sh != e.sw && (e.collider = { x: e.x + e.w / 3, y: e.y + e.h / 3.5, w: e.w / 3.5, h: e.h / 1.35, color: "rgba(255,0,0,0.5)" }), e.image || (e.collider = { x: e.x, y: e.y, w: e.w, h: e.h, color: "rgba(255,0,0,0.5)" })) }, self.removeCollider = function (e, t) { e.hasShadow = !1, e.flipX = t, e.collider = void 0 }, self.timer = (e, t) => { if (e == location.reload) { let s = setTimeout(function () { return clearTimeout(s), e }, t) } else if ("function" == typeof e) { let i = setTimeout(function () { return clearTimeout(i), e() }, t) } }, self.worldThroughCamera = function (e) { return (this.area = e, loader || isLoading && !this.area) ? { x: 0, y: 0, width: data.width * data.tilewidth, height: data.height * data.tileheight } : loader && (isLoading || !this.area) ? void 0 : { x: this.area.x, y: this.area.y, width: this.area.w, height: this.area.h } }; var l, r = !1; self.cameraLimit = !1, self.type = null, self.setCam = function (e, t, s) { var i, l, a, h; if (s = s || !1, x = Math.floor((camera = { x: 0, y: 0, width: gW / Math.round(self.scale), height: gH / Math.round(self.scale), color: "red" }).width / 2 + e.w / 2), y = Math.floor(camera.height / 2 + e.h / 2), void 0 == t) { buffer.translate(gW / 2 - (e.x - 5) >> 0, gH / 2 - (e.y - 5) >> 0); return } return "boolean" == typeof s && s && (r = s), camera.x = Math.round((i = camera.x, i + ((l = Math.floor(e.x + e.w + 1) - x) - i) * 1)), camera.y = Math.round((a = camera.y, a + ((h = Math.floor(e.y + e.h + 1) - y) - a) * 1)), camera.x <= 0 && (camera.x = 0), camera.y <= 0 && (camera.y = 0), camera.x >= t.width - camera.width && (camera.x = t.width - camera.width), camera.y > t.height - camera.height && (camera.y = t.height - camera.height), Math.round(e.x + camera.width * self.scale) >= x && (buffer.translate(Math.floor(-camera.x * self.scale), 0), isCamera = !0), e.y + camera.height * self.scale >= y && (buffer.translate(0, Math.floor(-camera.y * self.scale)), isCamera = !0), e.x < x && (isCamera = !1), e.y < y && (isCamera = !1), camera.x >= t.width - camera.width || camera.x <= 0 ? self.cameraLimit = !0 : self.cameraLimit = !1, camera.y >= t.height - camera.height || camera.y <= 0 ? "topdown" == self.type && (self.cameraLimit = !0) : self.cameraLimit = !1, this }; let a = 6; self.cameraShake = function (e, t) { this.intensity = e, --a <= 0 && (a = 0); var s = setInterval(() => { a > 0 && (dx = this.intensity * (Math.random() - .5) >> 0, dy = this.intensity * (Math.random() - .5) >> 0, buffer.setTransform(1, 0, 0, 1, dx, dy)) }, 50); setTimeout(() => { clearInterval(s), a = 6, buffer.setTransform(1, 0, 0, 1, 0, 0) }, t) }, self.renderBatch = function (e, t) { try { if (Array.isArray(e)) for (let s of e) s.type = t, "sheet" == s.type && (e.collider && canDraw(s.collider, camera) && self.renderObjects(s, s.type), canDraw(s, camera) && self.renderObjects(s, s.type)), "single" == s.type && (s.collider && canDraw(s.collider, camera) && self.renderObjects(s, s.type), canDraw(s, camera) && self.renderObjects(s, s.type)), "poly" == s.type && self.renderObjects(s, s.type), "circle" == s.type && canDraw(s, camera) && self.renderObjects(s, s.type), !s.type && canDraw(s, camera) && self.renderObjects(s); else e.type = t, "sheet" == e.type && (e.collider && canDraw(e.collider, camera) && self.renderObjects(e, e.type), canDraw(e, camera) && self.renderObjects(e, e.type)), "single" == e.type && (e.collider && canDraw(e.collider, camera) && self.renderObjects(e, e.type), canDraw(e, camera) && self.renderObjects(e, e.type)), "background" == e.type && self.renderObjects(e, e.type), "poly" == e.type && self.renderObjects(e, e.type), "circle" == e.type && canDraw(e, camera) && self.renderObjects(e, e.type), e.type || (canDraw(e, camera) && self.renderObjects(e), !canDraw(e, camera) && e.w >= camera.x + camera.width && self.renderObjects(e)) } catch (i) { } }, self.renderObjects = function (e, t) { this.type = t, "sheet" === this.type && e.drawSpriteSheet(), "single" === this.type && e.drawSpriteImg(), "background" === this.type && e.drawSpriteImg(), "circle" === this.type && e.drawCirc(), "poly" === this.type && e.draw(), this.type || e.drawSprite() }, self.stage.setBg(l); let h = 0, f, o = !1, n = 0, c, u = !1; function d(e) { buffer.clearRect(camera.x, camera.y, camera.width, camera.height); let t = e - h; h = e, t = Math.min(t, 1e3), self.isFrozen ? (f = 1e3 / self.freezeVal, t -= self.freezeVal) : t += self.fps; for (delta = (f / 1e3).toFixed(3), n += t, frame % 8 == 0 && isLayer && layerframe++, frame % 8 == 0 && isObject && objframe++; n >= f;)self.update(delta), n -= t, frame += 1; ctx.save(), buffer.save(), self.drawGame ? self.drawGame() : (ctx.save(), self.render(), ctx.restore()), particlePool.pool.length > 0 && function e() { for (let t = 0; t < particlePool.pool.length; t++) { let s = particlePool.pool[t]; s.update(), s.draw() } }(), snows.length > 0 && snows.forEach(function (e, t) { canDraw(e, camera) ? (buffer.beginPath(), buffer.fillStyle = e.color, buffer.arc(e.x, e.y += e.vy, e.r, 1.8, 1.7 * Math.PI), buffer.fill(), buffer.closePath()) : kill(snows, t) }), rains.length > 0 && rains.forEach((e, t) => { buffer.save(), e.drawSprite(), canDraw(e, camera) || kill(rains, t), buffer.restore() }), r && (buffer.strokeStyle = camera.color, buffer.lineWidth = 2 * self.scale, buffer.strokeRect(camera.x * self.scale, camera.y * self.scale, camera.width * self.scale, camera.height * self.scale)), buffer.restore(), ctx.clearRect(camera.x, camera.y, camera.width, camera.height), buffer.scale(1, 1), buffer.setTransform(1, 0, 0, 1, 0, 0), buffer.imageSmoothingEnabled = !1, buffer.imageSmoothingQuality = "low", g ? ctx.drawImage(g, 0, 0) : ctx.drawImage(stage2, 0, 0), ctx.drawImage(stage3, 0, 0), ctx.drawImage(stage4, 0, 0), ctx.restore(), c = requestAnimationFrame(d) } self.freezeVal = 1, self.isFrozen = !1, self.freeze = function (e, t) { self.isFrozen = !0; let s = performance.now(); f = 1e3 / (self.speed / t), self.freezeVal = self.speed / t; let i = () => { h - s < e ? setTimeout(i, e) : (self.isFrozen = !1, f = 1e3 / self.speed, self.freezeVal = self.speed) }; i() }, self.setAnimation = function (e) { return this.fps = e, o || (self.speed = this.fps, o = !0), f = 1e3 / self.speed, u = !1, c = requestAnimationFrame(d), this.fps }, self.stopAnimation = function () { u = !0, cancelAnimationFrame(c) }; let g = null; function $() { (g = new Image).src = stage2.toDataURL() } return setInterval(function () { !u && self.complexUpdate(delta) }, 30), kill = function (e, t) { return e.splice(t, 1) }, self.isHoriBorder = function (e, t) { if (null == e.r && null == t.x && camera) { if (e.x <= 0 || e.x >= t.width - e.w) return !0 } else if (null == e.r && null == t.x) { if (e.x <= 0 || e.x + e.w >= t.width) return !0 } else if (void 0 == e.r && void 0 !== t.x) { if (e.x <= t.x + 2 || e.x + e.w >= t.width) return !0 } else if (void 0 != e.r && void 0 != t.x) { if (e.x <= t.x || e.x + e.r >= t.width - e.r || e.x + e.r >= t.w - e.r) return !0 } else if (void 0 != e.r && void 0 == t.x && (e.x - e.r <= 0 || e.x + (e.r + 2 * e.r) >= t.width - e.r)) return !0; if (void 0 == e.r && void 0 == e.w && e.startX && void 0 == t.x && (e.startX <= e.radius - 4 || e.startX + e.radius - 2 >= t.width) || void 0 == e.r && void 0 == e.h && e.startX && void 0 != t.x && (e.startX <= e.radius - 4 || e.startX + e.radius - 2 >= t.w)) return !0 }, self.isVertiBorder = function (e, t) { if (void 0 == e.r && void 0 !== t.y) { if (e.y <= t.y || e.y + e.h >= t.height - e.h || e.y + e.h >= t.h) return !0 } else if (void 0 != e.r && void 0 !== t.y && (e.y - e.r <= t.y || e.y + e.r >= t.height - e.r || e.x + e.r >= t.h)) return !0; if (void 0 == e.r && void 0 == t.y) { if (e.y <= 0 || e.y + e.h >= t.height) return !0 } else if (void 0 != e.r && void 0 == t.y && (e.y - e.r <= 0 || e.y + (e.r + e.r) >= t.height)) return !0; if (void 0 == e.r && void 0 == e.h && e.startY && void 0 == t.y && (e.startY <= e.radius - 3 || e.startY + e.radius - 2 >= t.height) || void 0 == e.r && void 0 == e.h && e.startY && void 0 != t.y && (e.startY <= e.radius - 3 || e.startY + e.radius - 2 >= t.h)) return !0 }, self.setAstar = function (e, t, s, i, l) { let r = new Astar; return grid2d = new self.parse2D(t), r.setGrid(grid2d), r.setAcceptableTiles(s), r.setIterations(i), l && r.setDiagonal(l), r }, self.preventOverlapping = function (e) { for (let t = 0; t < e.length; t++) { let s = e[t]; for (let i = 0; i < e.length; i++) { let l = e[i]; if (s.checkCollision(l)) { kill(e, t), kill(e, i), i > t && i--; return } } } }, self } var row, column, data, Deg2Rad = Math.PI / 180; class Line { constructor(e, t, s, i, l, r) { this.x1 = e, this.x2 = t, this.y1 = s, this.y2 = i, this.color = l, this.width = r, this.vx = 0, this.vy = 0, this.round = !1, this.type = "line" } drawLine() { buffer.beginPath(), buffer.strokeStyle = this.color, this.round ? (buffer.lineJoin = "round", buffer.lineCap = "round") : (buffer.lineJoin = "miter", buffer.lineCap = "butt"), buffer.moveTo(this.x1, this.y1), buffer.lineTo(this.x2, this.y2), buffer.lineWidth = this.width, buffer.stroke(), buffer.closePath() } updateLine() { this.x2 += this.vx * delta, this.y2 += this.vy * delta } lineItersect = function (e) { var t = Game.getDistance(this, e); e.r ? t <= this.y1 && e.y + e.r >= this.y1 - 5 && (e.y = this.y1 - 5 - e.r, e.vy = 0) : t <= this.y1 && e.y + e.h >= this.y1 - 5 && (e.y = this.y1 - 5 - e.h, e.vy = 0) } } function PolyGons(e, t, s, i, l, r, a, h, f, o) { this.startX = e, this.startY = t, this.sides = s, this.radius = i, this.angle = r, this.color = l, this.speedX = a, this.speedY = h, this.effect = !1, this.fill = f || !1, this.canFire = o || !1, this.isRot = !1, this.type = "polygon", this.alpha = 1, "boolean" == typeof this.fill && (this.bullet = [], this.draw = function () { drawPolyBullet(this), buffer.save(), buffer.beginPath(), buffer.moveTo(this.startX + this.radius * Math.cos(0 + this.angle), this.startY + this.radius * Math.sin(0 + this.angle)); for (var e = 1; e <= this.sides; e++)3 == this.sides && this.flipX ? this.currentAngle = 1 - e * (2 * Math.PI) / this.sides + this.angle : this.currentAngle = e * (2 * Math.PI) / this.sides + this.angle, this.fill ? this.fill && (this.x = this.startX + this.radius * Math.cos(this.currentAngle), this.y = this.startY + this.radius * Math.sin(this.currentAngle), this.alpha, buffer.globalAlpha = this.alpha, buffer.lineWidth = 1, buffer.fillStyle = this.color, buffer.lineTo(Math.round(this.x), Math.round(this.y)), buffer.fill()) : (this.x = this.startX + this.radius * Math.cos(this.currentAngle), this.y = this.startY + this.radius * Math.sin(this.currentAngle), buffer.strokeStyle = this.color, buffer.lineWidth = 1, buffer.lineTo(Math.round(this.x), Math.round(this.y)), buffer.stroke()); buffer.lineTo(Math.round(this.startX + this.radius * Math.cos(0 + this.angle)), Math.round(this.startY + this.radius * Math.sin(0 + this.angle))), this.fill ? this.fill && (buffer.fillStyle = this.color, buffer.fill()) : (this.alpha, buffer.globalAlpha = this.alpha, buffer.strokeStyle = this.color, buffer.lineWidth = 2, buffer.stroke()), buffer.closePath(), buffer.restore() }, this.update = function () { buffer.save(), this.startX += this.speedX, this.startY += this.speedY, null != this.angle && (this.angle += .05), buffer.restore() }, this.checkCollision = function (e) { var t = this.startX - e.startX, s = this.startY - e.startY; return Math.sqrt(t * t + s * s) < this.radius + e.radius }, this.overlap = function (e) { for (let t = 0; t < e.length; t++) { let s = e[t]; for (let i = t + 1; i < e.length; i++) { let l = e[i]; s.checkCollision(l) && kill(e, i) } } }, this.addBullet = function (e, t, s, i, l, r, a, h) { this.obj = { x: e, y: t, w: s, h: i, color: l, r: r, angle: a || null, direction: this.direction(), fired: !1, speed: h }, (null != this.obj.direction || null != this.obj.angle) && this.bullet.push(this.obj) }, this.direction = function () { if (null == this.angle) { if (this.speedX > 0) return 1; if (this.speedX < 0) return -1; if (this.speedY > 0) return 2; if (this.speedY < 0) return -2 } }) } function drawPolyBullet(e) { this.bullet = e.bullet; for (let t = 0; t < this.bullet.length; t++)bul = this.bullet[t], e.effect && particlePool.createParticle(bul, 1e-5, "fire"), bul.image || (buffer.fillStyle = bul.color, this.isRot || (buffer.fillRect(Math.round(bul.x * self.scale), Math.round(bul.y * self.scale), Math.round(bul.w * self.scale), Math.round(bul.h * self.scale)), this.isRot = !1), (0 == bul.w && 0 == bul.h && null == bul.angle && -1 == bul.direction || 1 == bul.direction || -2 == bul.direction || 2 == bul.direction) && (buffer.beginPath(), buffer.arc(Math.round(this.bullet[t].x * self.scale), Math.round(this.bullet[t].y * self.scale), Math.round(this.bullet[t].r * self.scale), 0, Math.round(2 * Math.PI)), buffer.fill(), buffer.closePath()), 0 == bul.w && 0 == bul.h && null !== bul.angle && (buffer.beginPath(), buffer.arc(Math.round(bul.x * self.scale), Math.round(bul.y * self.scale), Math.round(bul.r * self.scale), 0, Math.round(2 * Math.PI)), buffer.fill(), buffer.closePath(), bul.x += Math.cos(bul.angle + 90 * Deg2Rad) * bul.speed, bul.y += Math.sin(bul.angle + 90 * Deg2Rad) * bul.speed, this.isRot = !0), 0 == bul.w || 0 == bul.h || null == bul.angle || (buffer.save(), buffer.translate(Math.round((bul.x + bul.w / 2) * self.scale), Math.round((bul.y + bul.h / 2) * self.scale)), buffer.rotate(bul.angle + 90 * Deg2Rad), buffer.fillRect(Math.round(-this.bullet[t].w / 2 * self.scale), Math.round(-this.bullet[t].h / 2 * self.scale), Math.round(this.bullet[t].w * self.scale), Math.round(this.bullet[t].h * self.scale)), buffer.restore(), bul.x += Math.cos(bul.angle + 90 * Deg2Rad) * bul.speed, bul.y += Math.sin(bul.angle + 90 * Deg2Rad) * bul.speed, this.isRot = !0)) } function isCollideBoxPolygon(e, t) { var s = e.startX - e.radius, i = e.startX + e.radius, l = e.startY - e.radius, r = e.startY + e.radius; if (void 0 == t.w) { var a = e.startX - t.x, h = e.startY - t.y; if (Math.sqrt(a * a + h * h) <= t.r + e.radius / 2 + t.r) return !0 } else var f = t.x; var o = t.x + t.w, n = t.y, c = t.y + t.h; return !!(i >= f) && !!(s <= o) && !!(r >= n) && !!(l <= c) } let Sprite = function (e, t, s, i, l, r, a, h, f) { this.x = e, this.y = t, this.w = s, this.h = i, this.vx = l, this.vy = r, this.id = h, this.rotation = f || 0, this.angle, this.isRot = !1, this.flipX = !1, this.flipY = !1, this.left = !1, this.alpha = 1, this.fadeOut = !1, this.hasShadow = !1, this.strong = !1, this.setGravity = function (e) { this.gravity = e, this.createShadow }, this.jumpTime = 0, this.isJumping = !1, this.color = a, this.setBody = e => { (!camera || canDraw(this, camera)) && (this.gv = e, void 0 == this.gv ? (this.setGravity(20), this.vy += .017 * this.gravity, this.y += Math.floor(this.vy), this.hasShadow = !1) : (this.gv > 20 && (this.gv = 20), this.setGravity(this.gv), this.setGravity(this.gv), this.vy += .017 * this.gravity, this.y += Math.floor(this.vy), this.hasShadow = !1)) }, this.removeBody = () => { this.vy = 0, this.strong = !1, this.onFloor = !0 }, this.createShadow = function (e) { this.shape = e, this.hasShadow = !0, this.r = 8, this.onFloor && (this.shadowY = this.collider.y + this.collider.h - 2), this.onFloor || (this.shadowY = this.collider.y + 2 * this.collider.h) }, this.color || (this.image = new Image), this.bullet = [], this.bullet.image = new Image, this.drawSprite = function () { this.hasShadow && (buffer.save(), "circle" == this.shape && (buffer.beginPath(), buffer.scale(1, .5), buffer.fillStyle = "rgba(0,0,0,0.5)", buffer.arc((this.x + this.w / 2) * self.scale, this.shadowY * self.scale * 2, this.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath()), "rect" == this.shape && (buffer.fillStyle = "rgba(0,0,0,0.5)", this.collider ? buffer.fillRect(this.collider.x * self.scale, this.shadowY * self.scale, this.collider.w * self.scale, this.collider.h * self.scale) : buffer.fillRect(this.x * self.scale, this.shadowY * self.scale, this.w * self.scale, this.h * self.scale)), buffer.restore()), this.vx > 0 ? this.left = !1 : this.vx < 0 && (this.left = !0), "number" == typeof this.angle && (this.isRot = !0); for (var e = 0; e < this.bullet.length; e++) { var t = this.bullet[e]; !t.image && (buffer.fillStyle = t.color, this.isRot && (null != t.angle || -1 != t.direction) && 1 != t.direction && -2 != t.direction && 2 != t.direction || (0 == t.w && 0 == t.h && t.r > 0 ? (buffer.beginPath(), buffer.arc(this.bullet[e].x * self.scale, this.bullet[e].y * self.scale, this.bullet[e].r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath()) : buffer.fillRect(t.x * self.scale, t.y * self.scale, t.w * self.scale, t.h * self.scale)), t.r > 0 && 0 == t.w && 0 == t.h && null != t.angle && !t.direction && (buffer.save(), buffer.beginPath(), buffer.arc(t.x * self.scale, t.y * self.scale, t.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath(), t.x += Math.cos(t.angle + 90 * Deg2Rad) * t.speed, t.y += Math.sin(t.angle + 90 * Deg2Rad) * t.speed, this.isRot = !0, buffer.restore()), t.w > 0 && t.h > 0 && 0 == t.r && null != t.angle && !t.direction && (buffer.save(), buffer.translate((t.x + t.w / 2) * self.scale, (t.y + t.h / 2) * self.scale), buffer.rotate(t.angle + 90 * Deg2Rad), buffer.fillRect(-this.bullet[e].w / 2 * self.scale, -this.bullet[e].h / 2 * self.scale, this.bullet[e].w * self.scale, this.bullet[e].h * self.scale), buffer.restore(), t.x += Math.cos(t.angle + 90 * Deg2Rad) * t.speed, t.y += Math.sin(t.angle + 90 * Deg2Rad) * t.speed, this.isRot = !0, buffer.restore())), t.image && (this.isRot || buffer.drawImage(this.bullet[e].image, this.bullet[e].x * self.scale, this.bullet[e].y * self.scale, this.bullet[e].w * self.scale, this.bullet[e].h * self.scale), t.angle && (buffer.save(), buffer.translate((t.x + t.w / 2) * self.scale, (t.y + t.h / 2) * self.scale), buffer.rotate(t.angle), buffer.drawImage(this.bullet[e].image, -(this.bullet[e].w / 2) * self.scale, -(this.bullet[e].h / 2) * self.scale, this.bullet[e].w * self.scale, this.bullet[e].h * self.scale), buffer.restore(), t.x += Math.cos(t.angle + 90 * Deg2Rad) * t.speed, t.y += Math.sin(t.angle + 90 * Deg2Rad) * t.speed, this.isRot = !0, buffer.restore())) } if (this.flipX && !this.rotation) for (var e = 0; e < this.bullet.length; e++) { if (this.bullet[e].image) { buffer.save(), buffer.scale(-1, 1), buffer.drawImage(this.bullet[e].image, -this.bullet[e].x * self.scale, this.bullet[e].y * self.scale, -this.bullet[e].w * self.scale, this.bullet[e].h * self.scale), buffer.restore(); return } if (this.bullet[e].w > 0 && this.bullet[e].h > 0) { buffer.save(), buffer.scale(-1, 1), buffer.fillStyle = this.bullet[e].color, buffer.fillRect(-this.bullet[e].x * self.scale, this.bullet[e].y * self.scale, -this.bullet[e].w * self.scale, this.bullet[e].h * self.scale), buffer.restore(); return } if (0 == this.bullet[e].w && 0 == this.bullet[e].h) { buffer.beginPath(), buffer.save(), buffer.scale(-1, 1), buffer.arc(-this.bullet[e].x * self.scale, this.bullet[e].y * self.scale, -this.bullet[e].r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath(), buffer.restore(); return } } if (this.rotation && !this.flipX && !rotImage) { buffer.save(), buffer.translate(this.x + this.w / 2 * self.scale, this.y + this.h / 2 * self.scale), buffer.rotate(this.rotation), buffer.fillStyle = this.color, buffer.fillRect(-this.w / 2 * self.scale, -this.h / 2 * self.scale, this.w * self.scale, this.h * self.scale), buffer.translate(-this.x * self.scale, -this.y * self.scale), buffer.restore(); return } if (this.rotation && this.flipX && !rotImage) { buffer.save(), buffer.translate(this.x - this.w / 2, (this.y - this.h / 2) * self.scale), buffer.scale(-1, 1), buffer.rotate(this.rotation), buffer.fillStyle = this.color, buffer.fillRect(-this.w / 2 * self.scale, -this.h / 2 * self.scale, this.w * self.scale, this.h * self.scale), buffer.restore(); return } buffer.globalAlpha = this.alpha, buffer.fillStyle = this.color, buffer.fillRect(this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale), this.isVisible && (buffer.fillStyle = this.collider.color, buffer.fillRect(this.collider.x * self.scale, this.collider.y * self.scale, this.collider.w * self.scale, this.collider.h * self.scale), this.flipX && (buffer.save(), buffer.scale(-1, 1), buffer.fillRect(-(this.collider.x + 4.2) * self.scale, this.collider.y * self.scale, -this.w / 2 * self.scale, this.collider.h * self.scale), buffer.restore())) }, this.reverse = !1, this.drawSpriteImg = function () { if (this.hasShadow && (buffer.save(), "circle" == this.shape && (buffer.beginPath(), buffer.fillStyle = "rgba(0,0,0,0.5)", buffer.arc((this.x + this.w / 2) * self.scale, this.shadowY * self.scale, this.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath()), "rect" == this.shape && (buffer.fillStyle = "rgba(0,0,0,0.5)", this.collider ? buffer.fillRect(this.collider.x * self.scale, this.shadowY * self.scale, this.collider.w * self.scale, this.collider.h * self.scale) : buffer.fillRect(this.x * self.scale, this.shadowY * self.scale, this.w * self.scale, this.h * self.scale)), buffer.restore()), this.vx > 0 ? this.left = !1 : this.vx < 0 && (this.left = !0), this.isVisible && (buffer.save(), buffer.fillStyle = this.collider.color, buffer.fillRect(this.collider.x * self.scale, this.collider.y * self.scale, this.collider.w * self.scale, this.collider.h * self.scale), buffer.restore()), this.show && (buffer.save(), buffer.fillStyle = this.detector.color, buffer.fillRect(this.detector.x * self.scale, this.detector.y * self.scale, this.detector.w * self.scale, this.detector.h * self.scale), buffer.restore()), this.flipX && !rotImage) for (var e = 0; e < this.bullet.length; e++) { if (imSet) { buffer.save(), buffer.scale(-1, 1), buffer.globalAlpha = this.alpha, buffer.drawImage(this.bullet[e].image, -this.bullet[e].x * self.scale, this.bullet[e].y * self.scale, -this.bullet[e].w * self.scale, this.bullet[e].h * self.scale), buffer.restore(); return } for (var t = 0; t < this.bullet.length; t++) { buffer.save(), buffer.scale(-1, 1), buffer.fillStyle = this.bullet[t].color, buffer.fillRect((-this.bullet[t].x - this.bullet[t].w) * self.scale, this.bullet[t].y * self.scale, this.bullet[t].w * self.scale, this.bullet[t].h * self.scale), buffer.globalAlpha = 1, buffer.restore(); return } } this.isRot = !1, 0 != this.angle ? this.isRot = !0 : this.isRot = !1; for (var e = 0; e < this.bullet.length; e++) { var s = this.bullet[e]; if (s.image || (buffer.fillStyle = this.bullet[e].color, s.angle ? 0 == this.bullet[e].w && 0 == this.bullet[e].h && void 0 != s.angle && (buffer.beginPath(), buffer.arc(Math.round(this.bullet[e].x + s.r / 2 * self.scale), Math.round(this.bullet[e].y + s.r / 2 * self.scale), Math.round(this.bullet[e].r * self.scale), 0, 2 * Math.PI), buffer.fill(), buffer.closePath(), s.x += Math.cos(s.angle - 90 * Deg2Rad) * s.speed, s.y += Math.sin(s.angle - 90 * Deg2Rad) * s.speed, this.isRot = !0) : (0 != this.bullet[e].r && -1 == s.direction || 1 == s.direction || -2 == s.direction || 2 == s.direction) && (buffer.save(), buffer.beginPath(), buffer.lineWidth = 1, buffer.arc(Math.round(this.bullet[e].x * self.scale), Math.round(this.bullet[e].y * self.scale), Math.round(this.bullet[e].r * self.scale), 0, 2 * Math.PI), buffer.fill(), buffer.closePath(), buffer.restore), 0 != s.r || void 0 == s.angle || (buffer.save(), buffer.translate(Math.round((s.x + s.w / 2) * self.scale), Math.round((s.y + s.h / 2) * self.scale)), buffer.rotate(s.angle), buffer.fillRect(-Math.round(this.bullet[e].w / 2 * self.scale), Math.round(-this.bullet[e].h / 2 * self.scale), Math.round(this.bullet[e].w * self.scale), Math.round(this.bullet[e].h * self.scale)), buffer.restore(), s.x += Math.cos(s.angle - 90 * Deg2Rad) * s.speed, s.y += Math.sin(s.angle - 90 * Deg2Rad) * s.speed, this.isRot = !0)), s.image && ((isRot || -1 != s.direction) && 1 != s.direction && -2 != s.direction && 2 != s.direction || s.flipX || buffer.drawImage(this.bullet[e].image, Math.round(this.bullet[e].x * self.scale), Math.round(this.bullet[e].y * self.scale), Math.round(this.bullet[e].w * self.scale), Math.round(this.bullet[e].h * self.scale)), void 0 != s.angle && (buffer.save(), buffer.translateMath.round((s.x + s.w / 2) * self.scale, Math.round((s.y + s.h / 2) * self.scale)), buffer.rotate(s.angle), buffer.drawImage(this.bullet[e].image, Math.round(-this.bullet[e].w / 2 * self.scale), Math.round(-this.bullet[e].h / 2 * self.scale), Math.round(this.bullet[e].w * self.scale), Math.round(this.bullet[e].h * self.scale)), buffer.restore(), s.x += Math.cos(s.angle + 90 * Deg2Rad) * s.speed, s.y += Math.sin(s.angle + 90 * Deg2Rad) * s.speed, isRot = !0)), this.bullet[e].image && this.bullet[e].flipX) { buffer.save(), buffer.scale(-1, 1), buffer.drawImage(this.bullet[e].image, Math.round(-this.bullet[e].x * self.scale), Math.round(this.bullet[e].y * self.scale), Math.round(-this.bullet[e].w * self.scale), Math.round(this.bullet[e].h * self.scale)), buffer.restore(); return } if (this.bullet[e].image && this.bullet[e].flipY) { buffer.save(), buffer.scale(1, -1), buffer.drawImage(this.bullet[e].image, Math.round(this.bullet[e].x * self.scale), Math.round(-this.bullet[e].y * self.scale), Math.round(this.bullet[e].w * self.scale), Math.round(-this.bullet[e].h * self.scale)), buffer.restore(); return } } if (this.angle && "up" == this.look || this.angle && "down" == this.look) { buffer.save(), centerX = Math.round((this.x + .5 * this.w) * self.scale), centerY = Math.round((this.y + .5 * this.h) * self.scale), buffer.translate(centerX, centerY), buffer.rotate(this.angle), this.angle <= 3 && this.reverse && buffer.scale(1, -1), this.angle <= -0 && this.reverse && buffer.scale(1, -1), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, Math.round(-this.w / 2 * self.scale), Math.round(-this.h / 2 * self.scale), Math.round(this.w * self.scale), Math.round(this.h * self.scale)), buffer.restore(); return } if (this.angle && "left" == this.look || "right" == this.look) { buffer.save(), centerX = (this.x + this.w / 2) * self.scale, centerY = (this.y + this.h / 2) * self.scale, buffer.translate(Math.round(centerX), Math.round(centerY)), buffer.rotate(this.angle), this.angle <= 3 && this.reverse && buffer.scale(1, -1), this.angle <= -0 && this.reverse && buffer.scale(1, -1), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, -this.w / 8 * self.scale, -this.h / 2 * self.scale, this.w * self.scale, this.h * self.scale), buffer.restore(); return } if (this.rotation && (rotImage = !0), this.flipX && !this.rotation) for (var e = 0; e < this.bullet.length; e++)if (this.bullet[e].image) buffer.drawImage(this.bullet[e].image, Math.round(-this.bullet[e].x * self.scale), Math.round(this.bullet[e].y * self.scale), Math.round(-this.bullet[e].w * self.scale), Math.round(this.bullet[e].h * self.scale)), buffer.globalAlpha = 1; else { if (this.bullet[e].w > 0 && this.bullet[e].h > 0) { buffer.save(), buffer.scale(-1, 1), buffer.fillStyle = this.bullet[e].color, buffer.fillRect(Math.round(-this.bullet[e].x * self.scale), Math.round(this.bullet[e].y * self.scale), Math.round(-this.bullet[e].w * self.scale), Math.round(this.bullet[e].h * self.scale)), buffer.restore(); return } if (0 == this.bullet[e].w && 0 == this.bullet[e].h) { buffer.beginPath(), buffer.save(), buffer.scale(-1, 1), buffer.arc(Math.round(-this.bullet[e].x * self.scale), Math.round(this.bullet[e].y * self.scale), Math.round(-this.bullet[e].r * self.scale), 0, Math.round(2 * Math.PI)), buffer.fill(), buffer.closePath(), buffer.restore(); return } } if (this.flipX && !rotImage) { if (rotImage) return; buffer.save(), buffer.scale(-1, 1), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, Math.round(-this.x * self.scale), Math.round(this.y * self.scale), Math.round(-this.w * self.scale), Math.round(this.h * self.scale)), buffer.globalAlpha = 0, buffer.restore(); return } if (this.flipY && !rotImage) { if (rotImage) return; buffer.save(), buffer.scale(1, -1), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, Math.round(this.x * self.scale), Math.round(-this.y * self.scale), Math.round(this.w * self.scale), Math.round(-this.h * self.scale)), buffer.restore(); return } if (!this.flipX && imSet && !rotImage) { if (rotImage) return; buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale) } if (!this.flipY && !this.rotation) { if (rotImage) return; buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale); return } if (this.rotation && this.flipX && rotImage) { buffer.save(), centerX = this.x * self.scale, centerY = this.y * self.scale, buffer.translate(Math.round(centerX), Math.round(centerY)), buffer.scale(-1, 1), buffer.rotate(this.rotation), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, Math.round(-this.w / 8), Math.round(-this.h / 2), this.w, this.h), buffer.restore(); return } if (this.rotation && !this.flipX && rotImage) { buffer.save(), centerX = this.x * self.scale, centerY = this.y * self.scale, buffer.translate(Math.round(centerX), Math.round(centerY)), buffer.rotate(this.rotation + 90 * Deg2Rad), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, Math.round(-this.w / 8), Math.round(-this.h / 2), this.w, this.h), buffer.restore(); return } }, this.addBullet = function (e, t, s, i, l, r, a, h) { this.obj = { x: e, y: t, w: s, h: i, color: l, r: r, angle: a, direction: this.direction(), fired: !1, speed: h }, (null != this.obj.direction || null != this.obj.angle) && this.bullet.push(this.obj) }, this.addBulletIm = function (e, t, s, i, l, r, a) { this.obj = { x: e, y: t, w: s, h: i, flipX: !1, flipY: !1, angle: r, direction: this.direction(), fired: !1, speed: a }, imSet = !0, this.obj.image = new Image, this.obj.image.src = l, (this.obj.direction || this.obj.angle) && this.bullet.push(this.obj) }, this.direction = () => { if (null == this.angle) { if (this.vx > 0) return 1; if (this.vx < 0) return -1; if (this.vy > 0) return 2; if (this.vy < 0) return -2 } }; var o = 0; this.SpriteRot = function () { o += 8, this.drawSpriteRot(o) }, this.drawSpriteRot = function (s) { buffer.save(), buffer.translate(e, t), buffer.rotate(s * Deg2Rad), buffer.fillStyle = this.color, buffer.fillRect(Math.round(-this.w / 2 * self.scale), Math.round(-this.h / 2 * self.scale), this.w * self.scale, this.h * self.scale), buffer.restore() }; var o = 0; this.SpriteRot = function () { o += 8, this.drawSpriteRot(o) }, this.drawSpriteImgRot = function (s) { return buffer.save(), buffer.translate(e, t), buffer.rotate(s * Deg2Rad), buffer.fillRect(Math.round(-this.w / 2 * self.scale), Math.round(-this.h / 2 * self.scale), this.w * self.scale, this.h * self.scale), buffer.restore(), this } }, Circle = function (e, t, s, i, l, r, a) { this.x = e, this.y = t, this.r = s, this.vx = i, this.vy = l, this.id = a, this.left = !1, this.setGravity = function (e) { this.gravity = e, this.isDrawn = !1, this.hasShadow = !1 }, this.jumpTime = 0, this.color = r, this.bullet = [], this.bullet.image = new Image, this.createShadow = function (e) { this.shape = e, this.hasShadow = !0, this.r = 8, this.onFloor && (this.shadowY = this.collider.y + this.collider.h - 2), this.onFloor || (this.shadowY = this.collider.y + 2 * this.collider.h) }, this.setBody = e => { (!camera || canDraw(this, camera)) && (this.gv = e, void 0 == this.gv ? (this.setGravity(20), this.vy += .017 * this.gravity, this.y += Math.floor(this.vy), this.hasShadow = !1) : (this.gv > 20 && (this.gv = 20), this.setGravity(this.gv), this.setGravity(this.gv), this.vy += .017 * this.gravity, this.y += Math.floor(this.vy), this.hasShadow = !1)) }, this.drawCirc = function () { for (b of (this.hasShadow && (buffer.save(), "circle" == this.shape && (buffer.beginPath(), buffer.scale(1, .5), buffer.fillStyle = "rgba(0,0,0,0.5)", buffer.arc((this.x + this.w / 2) * self.scale, this.shadowY * self.scale * 2, this.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath()), "rect" == this.shape && (buffer.fillStyle = "rgba(0,0,0,0.5)", this.collider ? buffer.fillRect(this.collider.x * self.scale, this.shadowY * self.scale, this.collider.w * self.scale, this.collider.h * self.scale) : buffer.fillRect(this.x * self.scale, this.shadowY * self.scale, this.w * self.scale, this.h * self.scale)), buffer.restore()), this.vx > 0 ? this.left = !1 : this.vx < 0 && (this.left = !0), buffer.beginPath(), buffer.fillStyle = this.color, buffer.arc(this.x * self.scale, this.y * self.scale, this.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath(), this.isDrawn = !0, this.bullet)) buffer.fillStyle = b.color, b.w > 0 && b.h > 0 && (buffer.fillStyle = buffer.fillRect(b.x * self.scale, b.y * self.scale, b.w * self.scale, b.h * self.scale)), 0 == b.w && 0 == b.h && (buffer.beginPath(), buffer.arc(b.x * self.scale, b.y * self.scale, b.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath()) }, this.addBullet = function (e, t, s, i, l, r, a) { this.obj = { x: e, y: t, w: s, h: i, color: l, r: r, direction: this.direction(), fired: !1, speed: a }, (this.obj.direction || this.obj.angle) && this.bullet.push(this.obj) }, this.addBulletIm = function (e, t, s, i, l, r) { this.obj = { x: e, y: t, w: s, h: i, flipX: !1, flipY: !1, direction: this.direction(), fired: !1, speed: r }, imSet = !0, this.obj.image = new Image, this.obj.image.src = l, (this.obj.direction || this.obj.angle) && this.bullet.push(this.obj) }, this.direction = function () { return this.vx < 0 ? -1 : this.vx > 0 ? 1 : this.vy < 0 ? -2 : this.vy > 0 ? 2 : void 0 } }, SpriteSheet = function (e, t, s, i, l, r, a, h, f, o, n) { this.row = t, this.col = e, this.sw = s, this.sh = i, this.x = l, this.y = r, this.w = a, this.h = h, this.vx = f, this.vy = o, this.id = n, this.angle, this.fadeOut = !1, this.isDead = !1, this.flipX = !1, this.flipY = !1, this.left = !1, this.isRot = !1, this.isFalling = !1, this.hasShadow = !1, this.setGravity = function (e) { this.gravity = e, this.isDrawn = !1 }, this.alpha = 1, this.jumpTime = 0, this.reverse = !1, this.createShadow = function (e) { this.shape = e, this.hasShadow = !0, this.r = 8, this.onFloor && (this.shadowY = this.collider.y + this.collider.h - 2), this.onFloor || (this.shadowY = this.collider.y + 2 * this.collider.h) }, this.setBody = e => { (!camera || canDraw(this, camera)) && (this.gv = e, void 0 == this.gv ? (this.setGravity(20), this.vy += .017 * this.gravity, this.y += Math.floor(this.vy), this.hasShadow = !1) : (this.gv > 20 && (this.gv = 20), this.setGravity(this.gv), this.setGravity(this.gv), this.vy += .017 * this.gravity, this.y += Math.floor(this.vy), this.hasShadow = !1)) }, this.isVisible = !1, this.show = !1, imSet = !0, this.image = new Image, this.bullet = [], this.bullet.image = new Image, this.drawSpriteSheet = function () { this.hasShadow && (buffer.save(), "circle" == this.shape && (buffer.beginPath(), buffer.scale(1, .5), buffer.fillStyle = "rgba(0,0,0,0.3)", this.flipX ? this.collider ? (buffer.arc(Math.round((this.x + this.w / 2) * self.scale), Math.round(this.shadowY * self.scale * 2, this.r * self.scale), 0, 2 * Math.PI), buffer.fill()) : (buffer.arc(Math.round(this.x + 6 + this.w / 2) * self.scale, Math.round(this.shadowY * self.scale * 2), this.r * self.scale, 0, 2 * Math.PI), buffer.fill()) : (buffer.arc(Math.round((this.x + this.w / 2) * self.scale), Math.round(this.shadowY * self.scale * 2), this.r * self.scale, 0, 2 * Math.PI), buffer.fill(), buffer.closePath())), "rect" == this.shape && (buffer.fillStyle = "rgba(0,0,0,0.3)", this.collider ? this.flipX ? buffer.fillRect((this.x + this.w / 3.5) * self.scale, (this.shadowY - 4) * self.scale, this.r * self.scale, this.r * self.scale) : buffer.fillRect(this.x + this.w / 3.5 * self.scale, (this.shadowY - 4) * self.scale, this.r * self.scale, this.r * self.scale) : buffer.fillRect(this.x * self.scale, this.shadowY * self.scale, this.w * self.scale, this.h * self.scale)), buffer.restore()), this.vx > 0 && (this.left = !1), this.vx < 0 && (this.left = !0), this.vy > 0 && !this.onFloor && (this.isFalling = !0), this.angle ? this.isRot = !1 : this.isRot = !0; for (var e = 0; e < this.bullet.length; e++) { var t = this.bullet[e]; this.drawAngularBullet(t), this.drawPixelBullet(t), this.drawImageBullet(t) } this.angle && "up" == this.look || this.angle && "down" == this.look ? (buffer.save(), centerX = Math.round((this.x + .5 * this.w) * self.scale), centerY = Math.round((this.y + .5 * this.h) * self.scale), buffer.translate(centerX, centerY), buffer.rotate(this.angle), this.angle <= 3 && this.reverse && buffer.scale(1, -1), this.flipY && buffer.scale(1, -1), this.angle <= -0 && this.reverse && buffer.scale(1, -1), buffer.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, Math.round(-this.w / 2 * self.scale), Math.round(-this.h / 2 * self.scale), Math.round(this.w * self.scale), Math.round(this.h * self.scale)), buffer.restore()) : (this.angle && "left" == this.look || this.angle && "right" == this.look) && (buffer.save(), centerX = Math.round((this.x + .5 * this.w) * self.scale), centerY = Math.round((this.y + .5 * this.h) * self.scale), buffer.translate(centerX, centerY), buffer.rotate(this.angle), this.angle <= 3 && this.reverse && buffer.scale(1, -1), this.angle <= -0 && this.reverse && buffer.scale(1, -1), buffer.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, Math.round(-this.w / 2 * self.scale), Math.round(-this.h / 2 * self.scale), Math.round(this.w * self.scale), Math.round(this.h * self.scale)), buffer.restore()), this.flipY && (buffer.save(), buffer.scale(1, -1), buffer.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, Math.round(this.x * self.scale), Math.round(-this.y * self.scale), Math.round(this.w * self.scale), Math.round(-this.h * self.scale)), buffer.restore()), this.flipX && (buffer.save(), buffer.scale(-1, 1), buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, Math.round(-(this.x + this.w) * self.scale), Math.round(this.y * self.scale), Math.round(this.w * self.scale), Math.round(this.h * self.scale)), buffer.restore()), this.flipX || this.rotation || void 0 != this.look || (buffer.globalAlpha = this.alpha, buffer.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)), this.isVisible && (buffer.save(), buffer.fillStyle = this.collider.color, buffer.fillRect(this.collider.x * self.scale, this.collider.y * self.scale, this.collider.w * self.scale, this.collider.h * self.scale), buffer.restore()), this.fadeOut && (buffer.save(), buffer.putImageData(this.pixel, this.x, this.y), buffer.restore()), this.show && (buffer.save(), buffer.fillStyle = this.detector.color, buffer.fillRect(this.detector.x * self.scale, this.detector.y * self.scale, this.detector.w * self.scale, this.detector.h * self.scale), buffer.restore()), this.enable && (buffer2.save(), this.render(), buffer2.restore()) }, this.addBullet = function (e, t, s, i, l, r, a, h) { this.obj = { x: e, y: t, w: s, h: i, color: l, r: r, angle: a, direction: this.direction(), fired: !1, speed: h }, (null != this.obj.direction || void 0 != this.obj.angle) && this.bullet.push(this.obj) }, this.addBulletIm = function (e, t, s, i, l, r, a) { this.obj = { x: e, y: t, w: s, h: i, flipX: !1, flipY: !1, angle: r, direction: this.direction(), fired: !1, speed: a }, this.obj.image = new Image, this.obj.image.src = l, this.bullet.push(this.obj) }, this.direction = function () { if (void 0 == this.angle) return this.vx > 0 ? 1 : this.vx < 0 ? -1 : 0 == this.gravity && this.vy > 0 ? 2 : 0 == this.gravity && this.vy < 0 ? -2 : null }, this.SpriteSheetRot = function (e) { e += 8, this.drawSpriteSheetRot(e) }, this.drawSpriteSheetRot = function (e) { buffer.save(), buffer.translate(Math.round(l * self.scale), Math.round(r * self.scale)), buffer.rotate(e * Deg2Rad), buffer.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, Math.round(-(this.w / 2) * self.scale), Math.round(-(height / 2) * self.scale), Math.round(this.w * self.scale), Math.round(this.h * self.scale)), buffer.restore() }, this.drawPixelBullet = function (e) { e.image || e.angle || ((e.w > 0 && 1 == e.direction || -1 == e.direction || -2 == e.direction || 2 == e.direction) && (buffer.fillStyle = e.color, buffer.fillRect(Math.round(e.x * self.scale), Math.round(e.y * self.scale), Math.round(e.w * self.scale), Math.round(e.h * self.scale))), (0 != e.w || e.angle || -1 != e.direction) && 1 != e.direction && -2 != e.direction && 2 != e.direction || (buffer.fillStyle = e.color, buffer.beginPath(), buffer.arc(Math.round(e.x * self.scale), Math.round(e.y * self.scale), Math.round(e.r * self.scale), 0, Math.round(2 * Math.PI)), buffer.fill(), buffer.closePath())) }, this.drawAngularBullet = function (e) { !e.image && e.angle ? (e.r > 0 && 0 == e.w && 0 == e.h && (buffer.fillStyle = e.color, buffer.save(), buffer.beginPath(), buffer.arc(Math.round((e.x + e.r / 3.5) * self.scale), Math.round((e.y + e.r / 3.5) * self.scale), Math.round(e.r * self.scale), 0, Math.round(2 * Math.PI)), buffer.fill(), buffer.closePath(), e.x += Math.cos(e.angle + 90 * Deg2Rad) * e.speed, e.y += Math.sin(e.angle + 90 * Deg2Rad) * e.speed, this.isRot = !0, buffer.restore()), 0 == e.r && e.angle && e.w > 0 && (buffer.fillStyle = e.color, buffer.save(), buffer.translate(Math.round((e.x + e.w / 2) * self.scale), Math.round((e.y + e.h / 2) * self.scale)), buffer.rotate(e.angle), buffer.fillRect(Math.round(-e.w / 2 * self.scale), Math.round(-e.h / 2 * self.scale), Math.round(e.w * self.scale), Math.round(e.h * self.scale)), e.x += Math.cos(e.angle + 90 * Deg2Rad) * e.speed, e.y += Math.sin(e.angle + 90 * Deg2Rad) * e.speed, this.isRot = !0, buffer.restore())) : e.image && e.angle && (buffer.save(), buffer.translate(Math.round((e.x + e.w / 3.5) * self.scale), Math.round((e.y + e.h / 3.5) * self.scale)), buffer.rotate(e.angle + 90 * Deg2Rad), buffer.drawImage(e.image, Math.round(-e.w / 3.5 * self.scale), Math.round(-e.h / 3.5 * self.scale), Math.round(e.w * self.scale), Math.round(e.h * self.scale)), buffer.restore(), e.x += Math.cos(e.angle + 90 * Deg2Rad) * e.speed, e.y += Math.sin(e.angle + 90 * Deg2Rad) * e.speed, this.isRot = !0) }, this.drawImageBullet = function (e) { e.image && !e.angle && (e.flipX || e.flipY || e.angle || buffer.drawImage(e.image, Math.round((e.x - 5) * self.scale), Math.round(e.y * self.scale), Math.round(e.w * self.scale), Math.round(e.h * self.scale)), e.flipX && !e.angle && (buffer.save(), buffer.scale(-1, 1), buffer.globalAlpha = 1, buffer.drawImage(e.image, Math.round(-(e.x - 5) * self.scale), Math.round(e.y * self.scale), Math.round(-e.w * self.scale), Math.round(e.h * self.scale)), buffer.restore(), buffer.globalAlpha = 0), e.flipY && !e.angle && (buffer.save(), buffer.scale(1, -1), buffer.drawImage(e.image, Math.round(e.x * self.scale), Math.round(-e.y * self.scale), Math.round(e.w * self.scale), Math.round(-e.h * self.scale)), buffer.restore())) } }; function isOverlap(e, t) { var s = Math.abs(t.x - (e.x + e.w / 2)), i = Math.abs(t.y - (e.y + e.h / 2)); if (s <= t.r + t.r + e.w / 2 && i <= t.r + t.r + e.h / 2) return !0 } function isCollide(e, t) { try { let s = e.y - t.y; if (e.x + e.w >= t.x && e.x <= t.x + t.w && e.y + e.h >= t.y && e.y <= t.y + t.h || e.x + e.w >= t.x && e.x <= t.x + t.width && e.y + e.h >= t.y && e.y <= t.y + t.height) { if (void 0 != t.gid) return !1; return !0 } if (s <= 1 && t.gid && e.x + e.w >= t.x && e.x <= t.x + t.width && e.y + e.h >= t.y - t.height && e.y <= t.y - t.height + t.height) return !0; return !1 } catch (i) { } } function isInterCirc(e, t) { if (dx = e.x - t.x, dy = e.y - t.y, sumr = e.r + t.r, (distance = Math.sqrt(dx * dx + dy * dy)) <= sumr) return !0 } function tileMap(e, t, s, i, l, r, a, h, f) { return this.image = new Image, this.image.src = a, this.lev = e, this.total = i, this.colTCount = t, this.rowTCount = e.length, this.ts = l * self.scale, this.s = r * self.scale, this.w = h, this.h = f, this.image.onload = () => this.drawLayer(), this.drawLayer = function () { for (var e = 0; e < this.rowTCount; e++)for (var t = 0; t < this.colTCount; t++) { var s = this.lev[e][t], i = s / this.total >> 0, a = s % this.total >> 0; a + l < camera.x || a + l > camera.x + camera.width + 100 || (isDrawable = !0), isDrawable && (void 0 == this.w && void 0 == this.h && buffer.drawImage(this.image, a * l, i * l, l * self.scale, l * self.scale, t * r, e * r, r * self.scale, r * self.scale), void 0 != this.w && void 0 != this.h && buffer.drawImage(this.image, a * l, i * l, l * self.scale, l * self.scale, t * r, e * r, this.w * self.scale, this.h * self.scale)) } }, this } function isFollow(e, t, s) { if (t.goLeft = !1, t.goRight = !1, s |= 140, t.collider && e.collider) { var i = Math.abs(e.collider.x - t.collider.x), l = Math.abs(e.collider.y - t.collider.y); return i <= 20 && i >= -25 ? void 0 : i <= s && l <= 30 && t.collider.x > e.collider.x ? (t.goLeft = !0, t.goRight = !1, !0) : i <= s && l <= 30 && t.collider.x < e.collider.x && (t.goLeft = !1, t.goRight = !0, !0) } } function createGrid(e, t, s, i) { this.gap = e, this.w = t, this.h = s, this.color = i, this.drawGrid = function () { buffer.beginPath(); for (var e = this.gap; e < this.w; e += this.gap)buffer.moveTo(e * self.scale, 0), buffer.lineTo(e * self.scale, this.h * self.scale), buffer.strokeStyle = this.color, buffer.stroke(), buffer.closePath(); for (var t = this.gap; t < this.h; t += this.gap)buffer.beginPath(), buffer.moveTo(0, t * self.scale), buffer.lineTo(this.w * self.scale, t * self.scale), buffer.strokeStyle = this.color, buffer.stroke(), buffer.closePath() } } function addNumber(e, t, s, i) { return this.col = e, this.row = t, this.tSize = s, this.color = i, this.spaceX = spaceX = s / 2 - 6, this.spaceY = spaceY = s / 2, this.show = () => { for (var e = 0; e <= this.row; e++)for (var t = 0; t <= this.col; t++) { var s = t + e * this.col; buffer.font = "10px arial bold", buffer.fillStyle = this.color, buffer.fillText(s, t * this.tSize * self.scale + this.spaceX * self.scale, e * this.tSize * self.scale + this.spaceY * self.scale) } }, this } SpriteSheet.prototype.useLight = function (e, t, s) { return this.r = e, this.opacity = t, this.darkness = s || 0, this.enable = !0, this.light = { x: this.x + this.w / 2, y: this.y + this.h / 2, r: this.r }, this.update = function () { this.light.x = this.x - (camera.x - this.w / 2) + this.w * delta, this.light.y = this.y - (camera.y - this.h / 2) + this.y * delta }, this.render = function () { ctx.clearRect(0, 0, gW, gH), buffer3.clearRect(0, 0, gW, gH), buffer3.save(), buffer3.imageSmoothingEnabled = !1, self.useDarkness(this.darkness), ctx.globalCompositeOperation = "lighter", buffer3.beginPath(), buffer3.fillStyle = `rgba(255,255,255,${this.opacity})`, ctx.globalCompositeOperation = "overlay", buffer3.arc(this.light.x * self.scale, this.light.y * self.scale, this.light.r * self.scale, 0, 2 * Math.PI), buffer3.fill(), buffer3.closePath(), buffer3.restore() }, this }; let loader = !1, that, isLoading = !1; var isLayer = !1, isObject = !1; function MapFromCollection(e, t) { that = this, that.path = e, that.src = t, that.load = function () { var e = new XMLHttpRequest; e.open("get", that.path), e.responseType = "json", e.send(), e.onreadystatechange = function () { if (4 == e.readyState) return isLoading = !0, data = e.response } } } MapFromCollection.prototype.renderLayer = function (e) { let t = data.tilesets; if ("tilelayer" === e.type && "objectgroup" != e.type) { let s = e.chunks; s.forEach(e => { let s = e.data, i = t[0].tilewidth, l = t[0].tileheight; t[0].tiles, s.forEach((s, r) => { if (null != s) { let a = new Image; try { layerImsrc = t[0].tiles[s].image, a.src = layerImsrc } catch (h) { } let f = e.x + r % e.width * i, o = e.y + Math.floor(r / e.width) * l; buffer2.imageSmoothingEnabled = !1, buffer.imageSmoothingEnabled = !1, buffer.drawImage(a, f, o, i, l) } }) }) } }, MapFromCollection.prototype.renderObjectLayer = function (e) { let t = data.tilesets; if ("objectgroup" === e.type) { let s = e.objects; s.forEach(e => { let s = new Image; s.src = t[0].tiles[e.gid - 1].image.replace(/..\/+/, `${that.src}/`), buffer.drawImage(s, e.x, e.y, e.width, e.height) }) } }; let isErrorDisplay = !1; function tiledMap(e, t) { return that = this, that.path = e, that.size = t, that.load = function () { (xhr = new XMLHttpRequest).onload = function () { if (4 == this.readyState) try { for (let e in data = JSON.parse(xhr.response)) e ? loader = !0 : log("no data") } catch (t) { } }, xhr.open("get", that.path), xhr.send(!0) }, that } var animLayer = !1; tiledMap.prototype.renderLayer = function (e, t) { let s = that.size; e.image = new Image, e.image.src = t; let i = e.width, l = e.height; for (let r = 0; r < l; r++)for (let a = 0; a < i; a++) { let h = a + r * i, f = e.data[h]; if (0 == f) continue; let o = data.tilesets.find(e => f >= e.firstgid && f < e.firstgid + e.tilecount); if (!o) continue; if (o.tiles && isDrawable) { o.firstgid; let n = data.tilesets.find(e => f >= e.firstgid && f < e.firstgid + e.tilecount); if (n) for (let c in n.tiles) { let u = n.tiles[c].animation, d = Date.now(), g = u.reduce((e, t) => e + t.duration, 0), $ = d % g, p = 0; for (let m of u) if ($ < (p += m.duration)) { f = o.firstgid + m.tileid; break } } } let w = f - o.firstgid, v = Math.floor(o.imagewidth / o.tilewidth); tX = w % v * s, tY = Math.floor(w / v) * s, dX = h % i * s, dY = Math.floor(h / i) * s, (isDrawable = dX + s >= camera.x && dX <= camera.x + camera.width + 100 && dY + s >= camera.y && dY <= camera.y + camera.height + 100) && (buffer.save(), buffer.globalAlpha = 1, buffer.drawImage(e.image, tX, tY, s, s, dX * self.scale, dY * self.scale, s * self.scale, s * self.scale), buffer.restore()) } }; var canAnimate = !1; function canDraw(e, t) { return e.gid ? !(e.x + e.width < t.x) && !(e.x + e.width > t.x + t.width) : !(e.x + e.w < t.x) && !(e.x + e.w >= t.x + t.width + 100) && !(e.y + e.h < t.y) && !(e.y + e.h >= t.y + t.height + 100) && !(e.x + e.r < t.x) && !(e.x + e.r >= t.x + t.width + 100) } function tiledCollider(e, t) { return !t.gid && e.x + e.w >= t.x && e.x <= t.x + t.width && e.y + e.h >= t.y && e.y <= t.y + t.height || !!t.gid && e.x + e.w >= t.x && e.x <= t.x + t.width && e.y + e.h >= t.y - t.height && e.y <= t.y - t.height + t.height || void 0 } tiledMap.prototype.objectAnimation = tileAnimation = function (e, t, s) { for (layer of (that.val = e, this.nom = t, that.image = new Image, that.image.src = s, data.layers)) if ("objectgroup" == layer.type && this.nom == layer.name) { let i = data.tilesets.find(e => that.val >= e.firstgid && that.val < e.firstgid + e.tilecount); if (i.tiles) { var l = i.tileheight, r = i.tilewidth; if (isObject = !0, data.tiledversion >= "1.11.0") for (let a in i.tiles) { var h, f = (anim = i.tiles[a].animation).length; for (var o of (frameIndex = objframe % f, h = anim[frameIndex].tileid, layer.objects)) o.hasOwnProperty("gid") && o.gid == that.val && this.nom == layer.name && "auto" != o.name || !o.hasOwnProperty("properties") ? canAnimate = !0 : (canAnimate = !1, isErrorDisplay || (log(" Animation Layer's name is not defined or gidValue is incorrect in tileAnimation \n\n please read the documentation so that you may use tileAnimation correctly !!"), isErrorDisplay = !0)), column = Math.floor(h % i.columns), objrow = Math.floor(h / i.columns), (isDrawable = !(o.x + l < camera.x) && !(o.x + l / 2 > camera.x + camera.width)) || (canAnimate = !1), canAnimate && (buffer.save(), buffer.globalAlpha = o.alpha || 1, buffer.drawImage(that.image, l * column, r * objrow, l, r, o.x * self.scale, (o.y - r) * self.scale, o.width * self.scale, o.height * self.scale), buffer.restore()) } else for (let n = 0; n < i.tiles.length; n++) { var h, f = (anim = i.tiles[n].animation).length; for (var o of (frameIndex = objframe % f, h = anim[frameIndex].tileid, layer.objects)) o.hasOwnProperty("gid") && o.gid == that.val && this.nom == layer.name && "auto" != o.name || !obl.hasOwnProperty("properties") ? canAnimate = !0 : (canAnimate = !1, isErrorDisplay || (log(" Animation Layer's name is not defined or gidValue is incorrect in tileAnimation \n\n please read the documentation so that you may use tileAnimation correctly !!"), isErrorDisplay = !0)), column = Math.floor(h % i.columns), objrow = Math.floor(h / i.columns), (isDrawable = !(o.x + l < camera.x) && !(o.x + l / 2 > camera.x + camera.width)) || (canAnimate = !1), canAnimate && (buffer.save(), buffer.globalAlpha = o.alpha || 1, buffer.drawImage(that.image, l * column, r * objrow, l, r, o.x * self.scale, (o.y - r) * self.scale, o.width * self.scale, o.height * self.scale), buffer.restore()) } } } }, tiledMap.prototype.RenderObjectLayer = function (e, t, s) { e.image = new Image, e.image.src = t, this.gid = s, e.objects.forEach(function (t) { t.alpha = 1; let s = t.gid, i = data.tilesets.find(e => s >= e.firstgid && s < e.firstgid + e.tilecount); i.rows = i.tilecount / i.columns; var l = Math.floor(i.imagewidth / i.columns), r = Math.floor(i.imageheight / i.rows); let a = Math.floor(t.gid - i.firstgid), h = a % i.columns, f = Math.floor(a / i.columns); t.x + i.tilewidth < camera.x || (t.x + i.tilewidth) * self.scale > (camera.x + camera.width) * self.scale ? iDrawable = !1 : isDrawable = !0, t.hasOwnProperty("gid") && t.gid != that.val && isDrawable && (buffer.save(), buffer.globalAlpha = t.alpha, buffer.drawImage(e.image, l * h, r * f, l, r, t.x * self.scale, (t.y - t.height) * self.scale, t.width * self.scale, t.height * self.scale), buffer.restore()) }) }; var isX = !1; function VrpgCollider(e, t) { e.objects.forEach(function (e) { let s = t.collider; if (t.collider) { if (isCollide(s, e)) { if (t.vy < 0 && s.y > e.y) { t.vy = 0, 0 == t.vy && ("circle" == t.shape && (this.shadowY = this.shadowY - 27), "rect" == t.shape && (this.shadowY = this.shadowY - 33)); let i = s.y - t.y; t.y = e.y + e.height - i + .01, s.y = e.y + e.height - i + .01; return } if (t.vy > 0 && e.y + e.height >= s.y) { t.vy = 0, t.jumpTime = 0; let l = s.y - t.y + s.h; t.y = e.y - l - .01; return } } } else t.x + t.w >= e.x && t.x <= e.x + e.width && t.y + t.h >= e.y && t.y <= e.y + e.height && (t.y = t.oldY) }) } function HrpgCollider(e, t) { (isX = 0 != t.vx) && !t.isJumping && (t.vy = 0), 0 != !t.vy && e.objects.forEach(function (e) { let s = t.collider; if (t.collider) { if (isCollide(s, e)) { if (t.vx > 0) { t.onFloor = !0, t.vy = 0; let i = s.x - t.x + s.w; return t.x = e.x - i - .01, !0 } if (t.vx < 0) { t.onFloor = !0, t.vy = 0; let l = s.x - t.x; return t.x = e.x + e.width - l + .01, !0 } } } else t.x + t.w >= e.x && t.x <= e.x + e.width && t.y + t.h >= e.y && t.y <= e.y + e.height && (t.x = t.oldX, t.y = t.oldY) }) } function avoidWalls(e, t, s) { for (let i of e) { var l = t.x - i.x; if (Math.hypot(l, t.y - i.y) < s) { let r = Math.atan2(i.y - t.y, i.x - t.x); t.vx -= Math.cos(r), t.vy -= Math.sin(r) } } } function RpgFollow(e, t, s, i) { this.gap = s, this.a = e, this.b = t; var l = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x), r = this.a.x - this.b.x, a = Math.hypot(this.a.y - this.b.y, r); if (!(18 >= Math.abs(a)) && a <= this.gap) { this.b.vx = Math.cos(l), this.b.vy = Math.sin(l), this.b.x += this.b.vx, this.b.y += this.b.vy; let h = Math.abs(this.a.x - this.b.x); if (this.a.y, this.b.y, e.x < t.x && h >= 5) return this.b.Rside = !1, this.b.Uside = !1, this.b.Dside = !1, avoidWalls(i, t, 300), this.b.Lside = !0; if (e.x > t.x && h >= 5) return this.b.Lside = !1, this.b.Uside = !1, this.b.Dside = !1, avoidWalls(i, t, 300), this.b.Rside = !0; if (e.y < t.y) return this.b.Rside = !1, this.b.Dside = !1, this.b.Lside = !1, avoidWalls(i, t, 300), this.b.Uside = !0; else if (e.y > t.y) return this.b.Rside = !1, this.b.Uside = !1, this.b.Lside = !1, avoidWalls(i, t, 300), this.b.Dside = !0; else return this.b.vx = 0, this.b.vy = 0, !1 } } function sideCollision(e, t) { let s = self.getObjectLayer(t); for (let i of s) if (isCollide(e, i)) { let l = e.x + e.w / 2 - (i.x + i.width / 2), r = e.y + e.h / 2 - (i.y + i.height / 2), a = (e.w + i.width) / 2, h = (e.h + i.height) / 2, f = a * r, o = h * l; Math.abs(l) <= a && Math.abs(r) <= h && (f > o ? f > -o ? e.y = i.y + i.height - .01 : e.x = i.x - e.w + .01 : f > -o ? e.x = i.x + i.width - .01 : (e.y = i.y - e.h + .01, e.hasOwnProperty("gravity") && (e.jumpTime = 0, e.onFloor = !0))), e.vx = 0, e.vy = 0 } } function topdownCollision(e, t) { let s = self.getObjectLayer(t); for (let i of s) { if (!e.collider) return; let l = e.collider, r = Math.abs(i.height - l.h) >> 0, a = Math.abs(i.y - l.y); if (isCollide(l, i) && canDraw(i, camera)) { if (e.vy > 0 && i.y + i.height > l.y && i.y > l.y - e.vy) { let h = Math.abs(l.y - e.y + l.h); e.y = i.y - h - .01, e.vy = 0, e.onFloor = !0, e.jumpTime = 0; return } if (e.vy < 0 && l.x - e.vx + l.w >= i.x - e.vx && i.y + i.height > l.y && l.y + l.h > i.y && l.x - e.vx <= i.x + i.width - e.vx && l.y <= i.y + i.height && l.y + l.h >= i.y + i.height && l.y > i.y) { let f = Math.abs(l.y - e.y); e.y = i.y + i.height - f + .01, e.vy = 0; return } if (e.vx > 0 && a < r) { let o = Math.abs(l.x - e.x + l.w); e.x = i.x - o - .01; return } if (e.vx < 0 && a < r) { let n = Math.abs(l.x - e.x); e.x = i.x + i.width - n + .01; return } } } } function SpawnEntities(e, t, s, i, l, r, a, h, f, o) { this.name = e, this.type = a, this.array = h, this.id = t, this.col = s, this.sw = l, this.sh = r, this.row = i, this.size = f, this.health = o, this.asyncOperation = async function () { if (loader) try { if ("sheet" == this.type) { for (let e of (this.container = self.getObjectLayer(this.name), this.container)) e.name == this.id && this.array.push(new SpriteSheet(this.col, this.row, this.sw, this.sh, e.x, e.y, this.size, this.size, 0, 0, this.id)); for (let t of this.array) t.health = this.health } else { for (let s of (this.container = self.getObjectLayer(this.name), this.container)) s.name == this.id && this.array.push(new Sprite(s.x, s.y, this.size, this.size, 0, 0, this.id)); for (let i of this.array) i.health = this.health } return this.container } catch (l) { log("failed" + l) } } } function gameRadar(e, t) { this.x = e, this.y = t; var s = new Image; s.src = this.x.toDataURL(), this.y.style.background = `url(${s.src})`, this.y.style.backgroundRepeat = "no-repat", this.y.style.backgroundSize = "cover" } var gameFrame = 0, gameSpeed = 5; class layerB { constructor(e, t, s, i, l, r) { this.x = t, this.y = s, this.image = e, this.w = i, this.h = l, this.speedModifier = r, this.speed = gameSpeed * this.speedModifier } update() { this.speed = gameSpeed * this.speedModifier, this.x = gameFrame * this.speed % this.w, isFake = !0 } draw() { isFake = !0, buffer.save(), 0 == gameFrame && buffer.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale), gameFrame < 0 ? (buffer.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale), buffer.drawImage(this.image, this.x * self.scale + this.w * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)) : gameFrame > 0 && (buffer.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale), buffer.drawImage(this.image, this.x * self.scale - this.w * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)), buffer.restore() } } var isJumping = !1; function LeftCollider(e, t, s, i) { for (var l = 0; l < e.length; l++)for (var r = 0; r < e[0].length; r++)if (e[l][r] == i) { var a = r * s, h = l * s; if (block = new Sprite(a, h, s, s, 0, 0, "red"), t.collider) { let f = t.collider; if (t.vx > 0 && f.x + f.w >= block.x && f.x <= block.x + block.w && f.y + f.h >= block.y && f.y <= block.y + block.h && f.y > block.y) { let o = f.x - t.x + f.w; t.x = block.x - o - .01; break } } else t.vx > 0 && t.x + t.w >= block.x && t.x <= block.x + block.w && t.y + t.h >= block.y && t.y <= block.y + block.h && (t.x = block.x - t.w - 1) } } function RightCollider(e, t, s, i) { for (var l = 0; l < e.length; l++)for (var r = 0; r < e[0].length; r++)if (e[l][r] == i) { var a = r * s, h = l * s; if (block = new Sprite(a, h, s, s, 0, 0, "red"), t.collider) { let f = t.collider; if (t.vx < 0 && f.x + f.w >= block.x && f.x <= block.x + block.w && f.y + f.h >= block.y && f.y <= block.y + block.h && f.y > block.y) { f.y, t.y, t.x = t.oldX + .01; break } } else if (t.vx < 0 && t.x + t.w >= block.x && t.x <= block.x + block.w && t.y + t.h >= block.y && t.y <= block.y + block.h) { t.x = block.x + block.w + 1; break } } } function TopCollider(e, t, s, i) { for (var l = 0; l < e.length; l++)for (var r = 0; r < e[0].length; r++) { var a = r * s, h = l * s, f = []; if (e[l][r] == i) { f.push(new Sprite(a, h, s, s, 0, 0, "red")); for (var o = 0; o < f.length; o++)var n = f[o]; if (t.collider) { let c = t.collider; if (isCollide(c, n) && t.vy > 0 && n.y + n.h >= c.y && n.y >= c.y + c.h / 2) { let u = c.y - t.y + c.h; return t.vy = 0, t.onFloor = !0, t.isFalling = !1, t.isJumping = !1, t.jumpTime = 0, t.y = ~~(n.y - u - .01) } } else if (isCollide(body, n) && t.vy > 0 && n.y + n.h > body.y && n.y > body.y + body.h / 2) { t.vy = 0, 0 == t.vy && ("circle" == t.shape && (this.shadowY = this.shadowY - 27), "rect" == t.shape && (this.shadowY = this.shadowY - 33)), t.y = n.y - t.h - .01, t.jumpTime = 0, t.onFloor = !0; break } } } } function BottomCollider(e, t, s, i) { for (var l = 0; l < e.length; l++)for (var r, a = 0; a < e[0].length; a++)if (e[l][a] == i) { if (r = { x: tx = a * s, y: ty = l * s, w: s, h: s }, t.collider) { let h = t.collider; if (t.isJumping || isJumping && t.vy < 0 && h.x - t.vx + h.w > r.x - t.vx && h.y + h.h >= r.y && h.x - t.vx <= r.x + r.w - t.vx && h.y <= r.y + r.h) { let f = h.y - t.y; t.y = r.y + r.h - 5 - f + 9, t.isJumping = !1, isJumping = !1, t.vy = 0; break } } else if (t.isJumping || isJumping && t.x + t.w > r.x && t.y + t.h >= r.y && t.x <= r.x + r.w && t.y <= r.y + r.h) { t.y = r.y + r.h + .01, t.vy = 0, isJumping = !1; break } } } function TopTiledCollider(e, t) { e.objects.forEach(function (e) { let s = t.collider; if (isCollide(s, e) && t.vy > 0 && e.y + e.height >= s.y && e.y > s.y - s.h) { let i = s.y - t.y + s.h; t.vy = 0, t.gravity = 0, t.onFloor = !0, t.isFalling = !1, t.isJumping = !1, t.jumpTime = 0, t.y = e.y - i - .001, t.collider.y = t.y; return } }) } function BottomTiledCollider(e, t) { e.objects.forEach(function (e) { let s = t.collider; if (canDraw(e, camera) && t.isJumping && t.vy < 0 && s.x - t.vx + s.w > e.x - t.vx && s.y + s.h >= e.y && s.x - t.vx <= e.x + e.width - t.vx && s.y <= e.y + e.height && s.y + s.h > e.y + e.height) { t.vy = 0; let i = s.y - t.y; t.y = e.y + e.height - 7 - i + 9, t.onFloor = !1, t.isJumping = !1; return } }) } function LeftTiledCollider(e, t) { e.objects.forEach(function (e) { if (!canDraw(e, camera)) return; let s = t.collider, i = e.y - s.y, l = Math.abs(e.height - s.h) >> 0; if (isCollide(s, e) && t.vx > .5 && i <= l) { let r = s.x - t.x + s.w; t.x = e.x - r - .01; return } }) } function RightTiledCollider(e, t) { e.objects.forEach(function (e) { if (!canDraw(e, camera)) return; let s = t.collider, i = e.y - s.y, l = Math.abs(data.tileheight - s.h) >> 0; if (isCollide(s, e) && t.vx < 0 && i <= l) { let r = s.x - t.x; t.x = e.x + e.width - r + .01; return } }) } function Platformer(e, t, s) { if (canDraw(e, camera)) { for (let i of data.layers) if (i.name == t) for (let l of i.objects) { if (!canDraw(l, camera)) return !1; if (!isCollide(body = e.collider, l) && Math.floor(e.vy) > 0 && (e.onFloor = !1), isCollide(body, l) && (dist = l.y - body.y, minHeight = Math.abs(l.height - body.h) >> 0, e.vy > 0 && l.y + l.height > body.y && l.y > body.y - e.vy)) { let r = body.y - e.y + body.h; e.vy = 0, e.gravity = 0, e.onFloor = !0, e.isFalling = !1, e.isJumping = !1, e.jumpTime = 0, e.y = l.y - r - .01; return } if (isCollide(body = e.collider, l) && canDraw(l, camera)) { if (e.isJumping && body.x - e.vx + body.w >= l.x - e.vx && e.vy < 0 && l.y + l.height > body.y && body.y + body.h > l.y && body.x - e.vx <= l.x + l.width - e.vx && body.y <= l.y + l.height && body.y + body.h >= l.y + l.height && body.y > l.y) { let a = body.y - e.y; e.y = l.y + l.height - a + .01, e.onFloor = !1, e.vy = 0; return } if (body = e.collider, !canDraw(l, camera)) return; if (body = e.collider, dist = l.y - body.y, minHeight = Math.abs(l.height - body.h) >> 0, isCollide(body, l) && e.vx > 0 && dist < minHeight) { let h = body.x - e.x + body.w; e.x = l.x - h - .01, s && (e.jumpTime = 0); return } if (!canDraw(l, camera)) return; if (body = e.collider, dist = l.y - body.y, minHeight = Math.abs(l.height - body.h) >> 0, isCollide(body, l) && e.vx < 0 && dist < minHeight) { let f = body.x - e.x; e.x = l.x + l.width - f + .01, s && (e.jumpTime = 0); return } } } } } class HealthBar { constructor({ x: e, y: t }, s, i, l, r) { if (this.height = s, this.bCol = i, this.jCol = l, this.position = { x: e, y: t }, this.obj = r, this.flip = !1, this.visible = !1, this.radius = "2.5px", this.isSet = !1, this.scale = 1.5, screen.width >= 1e3 && (this.scale = 5), this.border) return; this.border = document.createElement("div"), this.border.style.border = `2px solid ${this.bCol}`, this.border.style.position = "absolute", this.border.style.zIndex = 3, this.border.style.width = this.obj.health * this.scale + "px", this.border.style.height = this.height + "px", this.border.style.left = this.position.x + "px", this.border.style.top = this.position.y + "px", this.border.style.borderRadius = this.radius, this.juice = document.createElement("div"), this.border.appendChild(this.juice), this.jH = this.height - 2.5, this.juice.style.position = "absolute", this.juice.style.zIndex = 99999, this.juice.style.width = this.obj.health * this.scale + "px", this.juice.style.height = this.jH + "px", this.juice.style.background = this.jCol, this.juice.style.borderRadius = this.radius; let a = setInterval(() => { this.visible && !this.isSet && (self.add(this.border), this.isSet = !0, clearInterval(a)) }, 16) } destroy() { this.visible = !1 } update() { this.visible ? this.border.style.visibility = "visible" : this.border.style.visibility = "hidden", this.flip ? (this.border.style.transform = "scaleX(-1)", this.juice.style.width = this.obj.health * this.scale + "px", this.border.style.overflow = "hidden") : this.juice.style.width = this.obj.health * this.scale + "px" } } class PlaySound { constructor(e, t, s) { this.x = e, this.volume = t, this.type = s, this.audio = new Audio(this.x), this.audio.volume = this.volume, this.audio.preload = "auto" } run() { try { if (this.audio.currentTime = 0, "loop" === this.type) this.audio.autoplay = !0, this.audio.loop = !0, this.audio.play(); else try { this.audio.play() } catch (e) { } } catch (t) { console.error("Error playing audio:", t) } } stop() { try { this.audio.pause() } catch (e) { console.error("Error stopping audio:", e) } } } class Astar { constructor() { this.closedList = [], this.startNode = null, this.endNode = null, this.acceptableTiles = [], this.diagonalMovement = !1 } setGrid(e) { return this.grid = e } setAcceptableTiles(e) { return this.acceptableTiles = e } setDiagonal(e) { return this.diagonalMovement = e } setIterations(e) { this.timer = e } findPath(e, t, s, i, l) { if (!this.grid || e < 0 || t < 0 || s < 0 || i < 0 || e > this.grid[0].length || t > this.grid.length || s > this.grid[0].length || i > this.grid.length) { l(null); return } this.startNode = new Node(e, t), this.endNode = new Node(s, i), this.openList = [this.startNode], this.closedList = []; let r = 0, a = () => { let e = setTimeout(() => { for (; this.openList.length > 0 && r < 300;) { var t; this.currentNode = this.openList[0], this.currentIndex = 0; for (let s = 0; s < this.openList.length; s++)(this.openList[s].f < this.currentNode.f || this.openList[s].f === this.currentNode.f && this.openList[s].h < this.currentNode.h) && (this.currentNode = this.openList[s], this.currentIndex = s); if (this.openList.splice(this.currentIndex, 1), this.closedList.push(this.currentNode), this.currentNode.x === this.endNode.x && this.currentNode.y === this.endNode.y) { let i = [], h = this.currentNode; for (; null !== h;)i.push({ x: 0 | h.x, y: 0 | h.y }), h = h.parent; null == i && i.push(h); try { l(i.reverse()), clearTimeout(e) } catch (f) { } return } for (let o of t = this.diagonalMovement ? [[1, 1], [1, 0], [-1, 1], [-1, 0], [1, -1], [0, 1], [-1, -1], [0, -1]] : [[1, 0], [-1, 0], [0, 1], [0, -1]]) { let n = this.currentNode.x + o[0], c = this.currentNode.y + o[1]; if (n > 0 && n < this.grid[0].length && c > 0 && c < this.grid.length) { let u = new Node(n, c); if (u.isrunable = this.acceptableTiles.includes(this.grid[c][n]), u.isrunable && !this.closedList.some(e => e.x === u.x && e.y === u.y)) { let d = this.currentNode.g + 1; this.openList.some(e => e.x === u.x && e.y === u.y) ? d < u.g && (u.g = d, u.f = u.g + u.h, u.parent = this.currentNode) : (u.g = d, u.h = Math.abs(u.x - this.endNode.x) + Math.abs(u.y - this.endNode.y), u.f = u.g + u.h, u.parent = this.currentNode, this.openList.push(u)) } } } } ++r > 300 ? (l(null), clearTimeout(e)) : a() }, this.timer) }; a() } } class Node { constructor(e, t) { this.x = e, this.y = t, this.parent = null, this.g = 0, this.h = 0, this.isrunable = !0 } } function isFlipCollide(e, t) { var s = Math.abs(e.x - t.x), i = Math.abs(e.y - t.y); if (t.r && s <= t.r + t.r + e.w / 2 && i <= t.r + t.r + e.h / 2) return (!e.flipX || !(e.x < t.x)) && (!!e.flipX || !(e.x > t.x)); if (void 0 == t.r) { var s = Math.abs(e.x - t.x), i = Math.abs(e.y - t.y); if (!e.flipX && e.x + e.w >= t.x && e.x <= t.x + t.w && e.y + e.h >= t.y && e.y <= t.y + 1.8 * t.h) return !0; if (e.flipX && e.x + e.w >= t.x && e.x - 1.8 * e.w <= t.x + t.w && e.y + e.h >= t.y && e.y <= t.y + 1.8 * t.h) { if (e.flipX && e.x < t.x + t.w) return; return !0 } } } var partImage = new Image; function Particles(e, t, s, i, l, r) { this.name = l || "rainbow", this.speed = 4 * Math.random() - 2, this.angle = Math.random() * Math.PI * 6, i.collider ? (this.x = i.collider.x + s / 2, this.y = i.collider.y + 5) : (this.x = e + s / 2, this.y = t + 5), this.size = s * self.scale, this.alpha = 1, this.speed = 1.5 * Math.random() - 2, this.friction = .95, this.vx = Math.cos(this.angle) * this.speed, this.vy = Math.sin(this.angle) * this.speed, this.reset = function (i, l) { this.name = l || "rainbow", this.speed = 3 * Math.random() - 2, this.angle = Math.random() * Math.PI * 3, i.collider ? (this.x = i.collider.x + this.collider.w / 2, this.y = i.collider.y + 5) : (this.x = e + s / 4, this.y = t + 5), this.size = s * self.scale, this.alpha = 1, this.speed = .5 * Math.random() - 2, this.friction = .95, this.vx = Math.cos(this.angle) * this.speed, this.vy = Math.sin(this.angle) * this.speed }, this.update = function () { if (this.vx *= this.friction + .3, this.vy *= this.friction + .3, this.x += this.vx, this.vy -= .5, frame % 4 == 0 && (this.y += this.vy), "fire" == this.name) this.color = "#720", this.speed = .8, this.vx = Math.cos(this.angle) * this.speed, this.vy = Math.sin(this.angle) * this.speed, this.y += this.vy * this.friction, this.vx *= this.friction, this.x += this.vx * delta; else if ("dust" == this.name) { if (this.vx = -.5 * Math.random(), this.vy = -((Math.random() + 2.2) * Math.random() * 2), !i.onFloor) return; this.color = "lightgray", this.vy += 1.6, this.y = i.y + i.h - .4, this.y += .9 * this.vy, this.size = .8, i.vx > 0 && !i.isJumping ? this.x -= .5 + .2 * Math.random() * self.scale : i.vx > 0 && i.isJumping ? this.x -= .5 + .2 * Math.random() * self.scale : i.vx < 0 && !i.isJumping ? this.x -= .3 * Math.random() - 5 : i.vx < 0 && i.isJumping ? this.x -= 3 * Math.random() - 5 : i.vy > 0 && !i.isJumping ? this.y += -5 * Math.random() : i.vy < 0 && !i.isJumping && (this.y -= -5 * Math.random()) } else i.image && "self" == this.name ? (this.vx *= .8 * this.friction, this.x += this.vx * delta, this.vy += .5, this.y += this.vy * delta) : "rainbow" == this.name ? (this.color = "#" + Math.random().toString(16).substr(-6), this.speed = .5, this.vx = Math.cos(this.angle) * this.speed, this.vy = Math.sin(this.angle) * this.speed, this.y += this.vy * this.friction, this.vx *= this.friction, this.x += this.vx * delta) : i.image || "self" != this.name ? "waterfall" == this.name ? (this.y -= this.vy * this.friction * 10, this.vx *= this.friction, this.x += this.vx * delta, this.size = 5 * Math.random() + .9, this.color = "rgba(200,200,200,0.7)") : "blood" == this.name ? (this.color = "rgba(255,000,000,1)", this.speed = 1, this.vx = Math.cos(this.angle) * this.speed, this.vy = Math.sin(this.angle) * this.speed, this.y += this.vy * this.friction, this.vx *= this.friction, this.x += this.vx * delta) : "poison" == this.name ? (this.color = "rgba(205,80,255,0.8)", this.friction = .04, this.vx *= this.friction, this.vy -= .5, this.y += this.vy, this.x += this.vx) : "smoke" == this.name ? (this.color = "rgba(0,0,0,0.5)", this.friction = .4, this.vx *= this.friction, this.vy -= .1, this.y += this.vy, this.x += this.vx * delta) : i.color && (this.color = i.color) : (this.color = i.color, this.speed = 1, this.vx = Math.cos(this.angle) * this.speed, this.vy = Math.sin(this.angle) * this.speed, this.y += this.vy * this.friction, this.vx *= this.friction, this.x += this.vx * delta); if (frame % 10 == 0 && "dust" != this.name) for (let e = 0; e < particlePool.pool.length; e++) { let t = particlePool.pool[e]; t.dx = i.x - t.x, t.dy = i.y - t.y; var s = Math.hypot(t.dx, t.dy); "dust" != this.name && s >= 10 && (t.alpha -= .1, t.alpha <= .8 && (t.reset(i, this.name), particlePool.pool.pop(t))) } else if (frame % 2 == 0 && "dust" == this.name) for (let l = 0; l < particles.length; l++) { var r = particles[l]; r.dx = i.x - r.x, r.dy = i.y - r.y; var s = Math.hypot(r.dx, r.dy); s >= 2 && "dust" == this.name && (this.alpha -= .05, this.alpha <= .6 && (particlePool.pool[0] && (this.alpha = 1), kill(particlePool.pool, l))) } }, this.draw = function () { i.image && "self" == this.name ? (partImage.src = i.image.src, canDraw(i, camera) && buffer.drawImage(partImage, this.x * self.scale, this.y * self.scale, 1 * this.size, 1 * this.size)) : (canDraw(i, camera) && (buffer.fillStyle = this.color, "fire" == this.name ? (buffer.shadowBlur = 1, buffer.shadowColor = "rgba(240,200,10,0.8)") : buffer.shadowColor = this.color), canDraw(i, camera) && ("poison" != this.name && ("polygon" == i.type ? (buffer.globalAlpha = this.alpha, buffer.beginPath(), buffer.arc(this.x, this.y, this.size * Math.random() * .3 + .5, 1.2, 2 * Math.PI), buffer.fill(), buffer.closePath()) : (buffer.save(), buffer.beginPath(), buffer.arc(this.x * self.scale, this.y * self.scale, this.size * Math.random() * .3 + .5, 0, 2 * Math.PI), buffer.fill(), buffer.closePath(), buffer.restore())), "poison" == this.name && (buffer.beginPath(), "polygon" == i.type ? (buffer.beginPath(), buffer.arc(this.x, this.y, this.size * Math.random() * .8 + 1, 1.2, 2 * Math.PI), buffer.fill(), buffer.closePath()) : (buffer.beginPath(), buffer.arc(this.x * self.scale, this.y * self.scale, this.size * Math.random() * .8 + 1, 1.2, 2 * Math.PI), buffer.fill(), buffer.closePath())))) } } class ParticlePool { constructor() { this.pool = [], this.index = 0 } createParticle(e, t, s) { for (let i = 0; i < t; i++) { let l; this.index < this.pool.length ? (l = this.pool[this.index++]).reset(e, s) : (l = new Particles(e.x + (e.w || 0) / 2, e.y, 2 * Math.random() + .05, e, s), this.pool.push(l), t > 40 && (t = 5), this.index++) } } getPoolSize() { return this.pool.length } resetPool() { this.index = 0 } } var particlePool = new ParticlePool; class UseText { constructor(e, t, s, i, l, r) { this.text = e, this.color = r, this.size = s, this.x = i, this.y = l, this.degree = 0, this.value = t, this.visible = !1, this.paragraph || (this.paragraph = document.createElement("p"), document.addEventListener("DOMContentLoaded", () => { document.body.appendChild(this.paragraph) }), null == this.text ? this.paragraph.innerText = this.value : "number" == typeof this.text ? this.paragraph.innerText = this.text + this.value : this.paragraph.innerText = this.text + " " + this.value, this.paragraph.style.position = "absolute", this.paragraph.style.zIndex = 3, this.paragraph.style.left = `${this.x}px`, this.paragraph.style.top = `${this.y}px`, this.paragraph.style.fontSize = `${this.size}px`, this.paragraph.style.color = `${this.color}`, setInterval(() => { this.visible ? this.paragraph.style.visibility = "visible" : this.paragraph.style.visibility = "hidden" }, 16)) } rotate(e) { this.degree = e } destroy() { document.body.removeChild(this.paragraph), this.paragraph.innerText = null } animate(e) { setTimeout(() => { this.paragraph.style.color = this.color }, 1e3), setTimeout(() => { this.paragraph.style.color = e }, 2500) } update(e) { this.updatedValue = e, this.updator = this.updatedValue, this.paragraph.style.transform = `rotate(${this.degree}deg)`, this.paragraph.style.position = "absolute", this.paragraph.style.zIndex = 3, this.paragraph.style.left = `${this.x}px`, this.paragraph.style.top = `${this.y}px`, this.paragraph.style.fontSize = `${this.size}px`, this.paragraph.style.color = `${this.color}`, this.paragraph.style.zIndex = 3, null == this.text ? this.paragraph.innerText = this.updator : this.paragraph.innerText = this.text + " " + this.updator, this.visible ? this.paragraph.style.visibility = "visible" : this.paragraph.style.visibility = "hidden" } } function hitBox(e, t, s) { if (e.collider && t.collider) var i = Math.abs(e.collider.x - t.collider.x), l = Math.abs(e.collider.y - t.collider.y); if (e.collider && !t.collider) var i = Math.abs(e.collider.x - t.x), l = Math.abs(e.collider.y - t.y); else var i = Math.abs(e.x - t.x), l = Math.abs(e.y - t.y); if (Math.hypot(i, l) <= s) { if (e.left) { if (e.collider && t.collider && e.collider.x > t.collider.x) return !0; if (e.collider && !t.collider) { if (e.collider.x > t.x) return !0 } else if (!e.collider && !t.collider && e.x > t.x) return !0 } if (!e.left) { if (e.collider && t.collider && e.collider.x < t.collider.x) return !0; if (e.collider && !t.collider) { if (e.collider.x < t.x) return !0 } else if (!e.collider && !t.collider && e.x < t.x) return !0 } } return !1 } function SnowEffect(e) { num = [-3, 3], this.space = e; for (var t = { x: Math.round(Math.random() * camera.width) + camera.x, y: 0, s: Math.floor(1 * Math.random()) + .5, color: "rgb(255, 255, 255)" }, s = 0; s < 15; s += 2)rand = Math.random() * num.length, snows.push(new Circle(t.x, t.y, t.s, Math.cos(num[rand]), Math.floor(1 * Math.random()) + 1, t.color)); for (var i = 0; i < snows.length; i++)snow = snows[i], snow.y += 1 } function RainEffect(e) { this.space = e; for (var t = [-1, 3], s = { x: Math.floor(Math.random() * camera.width) + camera.x, y: 0, w: Math.floor(1 * Math.random()) + .05 * 3, h: 8, color: "rgba(255, 255, 255, 0.3)" }, i = 0; i < 10; i += 2)rand = Math.random() * t.length, rains.push(new Sprite(s.x, s.y, s.w, s.h, Math.cos(t[rand]), Math.floor(1 * Math.random()) + 2, s.color)); rains.forEach(function (e, t) { e.y += 5 }) } log("CanvasGameJs is running !!"); let isPoint = !1; function renderRWayPoint() { if (isPoint) { buffer.beginPath(), buffer.strokeStyle = "darkblue", buffer.moveTo(wayPoints[0].x * self.scale, wayPoints[0].y * self.scale); for (let e = 0; e < wayPoints.length; e++) { let t = wayPoints[e]; buffer.lineTo(t.x * self.scale, t.y * self.scale) } buffer.stroke(), buffer.closePath() } } let wp; function isPath(e, t, s, i) { let l = !1; for (let r of i) if (lineSegmentIntersectsObstacle(t, s, r)) { l = !0; break } return l ? (wp = e[0], !1) : (moveAlongPath(e, t, s, i), !0) } function lineSegmentIntersectsObstacle(e, t, s) { let i = e.x, l = e.y, r = t.x, a = t.y, h = s.x, f = s.y, o = s.x + s.width, n = s.y + s.height, c = ((o - h) * (l - f) - (n - f) * (i - h)) / ((n - f) * (r - i) - (o - h) * (a - l)), u = ((r - i) * (l - f) - (a - l) * (i - h)) / ((n - f) * (r - i) - (o - h) * (a - l)); return c >= 0 && c <= 1 && u >= 0 && u <= 1 } function moveAlongPath(e, t, s, i) { if (pathIndex < 0 || pathIndex >= e.length - 1) return; wp = e[pathIndex], isPoint = !0; let l = wp.x - t.x, r = Math.atan2(wp.y - t.y, l), a; if (i.some(e => lineSegmentIntersectsObstacle({ x: t.x, y: t.y }, { x: wp.x, y: wp.y }, { x: e.x + 8, y: e.y + 8, width: e.width + 8, height: e.height + 8 }))) { let h = self.getAngle(t, e[0]); t.vx = 1 * Math.cos(h), t.vy = 1 * Math.sin(h) } else t.vx = 1 * Math.cos(r), t.vy = 1 * Math.sin(r); e.length > 0 && (t.x += t.vx, t.y += t.vy, pathIndex++), Math.abs(Math.round(t.x) - Math.round(wp.x)) < Math.abs(t.vx) && Math.abs(Math.round(t.y) - Math.round(wp.y)) < Math.abs(t.vy) && pathIndex < e.length - 1 && (pathIndex++, isPoint = !0, e.splice(0, pathIndex)) } class GridSize { constructor(e, t) { this.cellSize = e, this.grid = gW / this.cellSize, this.gridSize = this.grid } } class Snake extends GridSize { constructor(e, t, s, i, l, r) { super(i, r), this.cellSize = i, this.color = l, this.headColor = e, this.dir = { x: 0, y: 0 }, this.lost = !1, this.length = 5, this.segments = [], this.oldDir = { x: 0, y: 0 }, this.position = { x: t, y: s } } grow() { this.length++ } update() { frame % 2.5 == 0 && (this.position.x += this.dir.x * this.cellSize, this.position.y += this.dir.y * this.cellSize, this.segments.unshift({ x: this.position.x, y: this.position.y }), this.segments.length > this.length && this.segments.pop(), (this.segments[0].x * self.scale < 0 || Math.round((this.segments[0].x + this.cellSize) * self.scale) >= gW || 0 > Math.round(this.segments[0].y * self.scale) || Math.round((this.segments[0].y + this.cellSize) * self.scale) >= gH) && (this.lost = !0), (this.dir.x == -this.oldDir.x && 0 != this.dir.x || this.dir.y == -this.oldDir.y && 0 != this.dir.y) && (this.lost = !0), this.oldDir.x = this.dir.x, this.oldDir.y = this.dir.y) } draw() { for (var e = 0; e < this.segments.length; e++)0 == e ? buffer.fillStyle = this.headColor : buffer.fillStyle = this.color, buffer.fillRect(Math.round(this.segments[e].x * self.scale), Math.round(this.segments[e].y * self.scale), Math.round(this.cellSize * self.scale), Math.round(this.cellSize * self.scale)) } eatSelf() { for (let e = 0; e < this.segments.length; e++) { let t = this.segments[e]; e > 5 && t.x === this.position.x && t.y === this.position.y && (this.lost = !0) } } } function collidedFood(e, t) { if (e.x == t.x && e.y == t.y) return !0 } class Food extends GridSize { constructor(e, t, s) { super(e, t), this.cellSize = e, this.color = s, this.useImage = !1, this.image = new Image, this.size = this.cellSize, this.generateFood() } generateFood() { this.randomX = Math.floor(Math.random() * this.gridSize) * this.cellSize, this.randomY = Math.floor(Math.random() * this.gridSize) * this.cellSize, this.x = this.randomX, this.y = this.randomY } update() { (this.x * self.scale <= 15 || (this.x + this.cellSize) * self.scale > gW || this.y * self.scale <= 15 || (this.y + this.cellSize) * self.scale > gH) && this.generateFood() } draw() { this.useImage ? buffer.drawImage(this.image, Math.round(this.x * self.scale), Math.round(this.y * self.scale), Math.round(this.size * self.scale), Math.round(this.size * self.scale)) : (buffer.fillStyle = this.color, buffer.fillRect(Math.round(this.x * self.scale), Math.round(this.y * self.scale), Math.round(this.size * self.scale), Math.round(this.size * self.scale))) } } class TinyBar { constructor(e, t, s, i) { this.obj = s, this.x = this.obj.x + 10, this.y = s.y - 10, this.h = e, this.color = t, this.borderColor = i, this.value = 1.3 * this.obj.health, this.w = 1.3 * this.obj.health, this.obj.startX && (this.x = this.obj.startX - this.obj.radius / 2.5, this.y = this.y - 10) } update(e) { this.remain = e, this.x = this.obj.x + 10, this.y = this.obj.y - 10, this.w = 1.3 * this.remain, this.w <= 0 && (this.w = 0), this.destroy(), this.obj.startX && (this.x = this.obj.startX - this.obj.radius / 2.5, this.y = this.y - 10) } draw() { buffer.clearRect(this.x, this.y, this.w, this.h), buffer.save(), buffer.strokeStyle = this.borderColor || "silver", buffer.strokeRect(this.x * self.scale, this.y * self.scale, this.value * self.scale, this.h * self.scale), buffer.fillStyle = this.color, buffer.fillRect(this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale), buffer.restore() } destroy() { this.w <= 0 && (this.value = 0, this.w = 0, this.h = 0) } } let getEntityCount = function (e, t, s) { let i = setInterval(() => { if (loader) { if (t) { let l = self.getObjectLayer(e); l.length > maxEntity && (maxEntity = l.length), clearInterval(i), s(maxEntity) } else { let r = self.getObjectLayer(e); clearInterval(i), s(r.length) } } }, 16) }; window.getEntityCount = getEntityCount;